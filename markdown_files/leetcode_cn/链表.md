# [leetcode_cn_专题系列]01链表

[链表知识点题库 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/tag/linked-list/problemset/)

```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```



# leetcode



## [2. 两数相加 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/add-two-numbers/)

### 题目描述

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

示例 2：

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

示例3：

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

### 解法1 递归

- 如果`l1.val + l2.val < 10`，不需要考虑进位，加和直接作为和链表当前节点的值，且下一个节点为`addTwoNumbers(l1.next, l2.next)`
- 如果`l1.val + l2.val >= 10`，需要考虑进位，且进位只可能为1。加和减去10作为和链表当前节点的值，且下一个节点为三个节点的值相加：构造一个值为1的`ListNode`表示进位，`l1.next`和`l2.next`，通过两次调用递归函数得到`addTwoNumbers(addTwoNumbers(l1.next, carry), l2.next)`

```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1:
            return l2
        if not l2:
            return l1
        cur_val = l1.val + l2.val
        if cur_val < 10:
            l3 = ListNode(cur_val)
            l3.next = self.addTwoNumbers(l1.next, l2.next)
        else:
            l3 = ListNode(cur_val - 10)
            carry = ListNode(1)
            l3.next = self.addTwoNumbers(self.addTwoNumbers(l1.next, carry), l2.next)
        return l3
```

### 解法2 迭代

- 定义一个进位节点carry
- `l1`, `l2`和`carry`只要有一个节点不为空，就继续迭代
- 当前节点的值为`(l1.val + l2.val + carry.val) mod 10`，如果节点为空，则值定义为0。如果`(l1.val + l2.val + carry.val) >= 10`，则进位节点的值为`(l1.val + l2.val + carry.val) // 10`，否则进位节点置为None
- 更新`l1`和`l2`

```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(-1)
        res = dummy
        carry = None
        while l1 or l2 or carry:
            val1 = l1.val if l1 else 0
            val2 = l2.val if l2 else 0
            cval = carry.val if carry else 0
            cur_val = val1 + val2 + cval
            carry = None if cur_val < 10 else ListNode(1)
            res.next = ListNode(cur_val % 10)
            res = res.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        return dummy.next
```






## [19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

### 题目描述

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

示例 1：

![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

示例 2：

```
输入：head = [1], n = 1
输出：[]
```

示例 3：

```
输入：head = [1,2], n = 1
输出：[1]
```

### 解法1 快慢指针

- 删除倒数第n个节点，需要找到倒数第n+1个节点p，然后通过`p.next = p.next.next`就可以删掉倒数第n个节点`p.next`了。
- 寻找倒数第n+1个节点p的方法——快慢指针，以`1->2->3->4->5`，n=2为例
  - 第一步，定义一个dummy节点指向head，即`0->1->2->3->4->5`
  - 第二步，找到正数第n个节点，从0出发，向右跑n步，定义为fast节点，即2
  - 第三步，slow节点从0出发，fast节点从第n个节点(即2)出发，一起向右跑。fast节点右边还有length-n(5-2=3)个节点，那么当fast节点跑到最后一个节点5时，slow节点从0往右跑了length-n步，正数length-n个节点就是倒数第n+1个节点
  - 注意dummy节点不计入正数和倒数的索引中

```python
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        dummy = ListNode(0, head)
        fast = dummy
        for _ in range(n):
            fast = fast.next
        slow = dummy
        while fast.next:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return dummy.next
```



## [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

### 题目描述

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

示例 1：

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```



示例 2：

```
输入：l1 = [], l2 = []
输出：[]
```



示例 3：

```
输入：l1 = [], l2 = [0]
输出：[0]
```

这题和[2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)很相似，但是更简单

### 解法1 递归

```python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1:
            return l2
        if not l2:
            return l1
        if l1.val < l2.val:
            l3 = ListNode(l1.val)
            l3.next = self.mergeTwoLists(l1.next, l2)
        else:
            l3 = ListNode(l2.val)
            l3.next = self.mergeTwoLists(l1, l2.next)
        return l3
```

## [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

### 题目描述

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。



示例 1：

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```



示例 2：

``` 
输入：lists = []
输出：[]
```



示例 3：

```
输入：lists = [[]]
输出：[]
```




提示：

```
k == lists.length
0 <= k <= 10^4
0 <= lists[i].length <= 500
-10^4 <= lists[i][j] <= 10^4
lists[i] 按 升序 排列
lists[i].length 的总和不超过 10^4
```





# 剑指offer



# 面试题

