# [leetcode_soulmachine]01线性表/数组

## 1. [[26]删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

### 题目描述

给你一个有序数组 `nums` ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

示例 1：

```
输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```


示例 2：

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

### 思路

双指针法。

遍历数组，一个指针指向当前遍历到的位置，一个指针指向`删除重复元素后`的位置。

### 解法

#### 解法1：使用API

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        return distance(nums.begin(), unique(nums.begin(), nums.end()));
    }
};
```

#### 解法2：双指针——使用`索引`

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() < 2) return nums.size();
        int index = 0;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] != nums[index]) {
                nums[++index] = nums[i];
            }
        }
        return index+1;
    }
};
```

#### 解法3：双指针——使用`迭代器`

标准库API的具体实现，参考https://en.cppreference.com/w/cpp/algorithm/unique

first 指向去重前的数组中的element， result指向去重后的数组中的element

- 以[1,1,2]为例，while每遍历一次，判断条件中都会++first
  - first指向第一个1, result指向第一个1。检测到!(*result == *first)为false则退出if并进行下一次循环，++result不会触发。
  - first指向第二个1, result指向第一个1。检测到!(*result == *first)为false则退出if并进行下一次循环，++result不会触发。
  - first指向2，result指向第2个1，检测到!(*result == *first)为true，再检查++result != first也为true才进行move操作。如果++result == first，表示result的下一个迭代器是first，不需要move操作。

- 以[1,2,2]为例，while每遍历一次，判断条件中都会++first
  - first指向1, result指向1。检测到!(*result == *first)为false则退出if并进行下一次循环，++result不会触发。
  - first指向第一个2, result指向1。检测到!(*result == *first)为true，再检查++result != first，发现为false，即result+1 == first，不需要将first值给到result。
  - first指向第二个2，result指向第一个2，检测到!(*result == *first)为false则退出if并进行下一次循环，++result不会触发。

result表示的含义是循环进行到当前这一步时已经生成的非重数组的最大索引

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        return distance(nums.begin(), unique(nums.begin(), nums.end()));
    }

    template<class ForwardIt>
    ForwardIt unique(ForwardIt first, ForwardIt last)
    {
        if (first == last)
            return last;
        ForwardIt result = first;
        while (++first != last) {
            if (!(*result == *first) && ++result != first) {
                *result = std::move(*first);
            }
        }
        return ++result;
    }
};
```



## 2. [[80]删除有序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

### 题目描述

给你一个有序数组`nums`，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

示例 1：

```
输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。
```


示例 2：

```
输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。
```

### 思路

`i`指去重前的索引，`index`指去重后的索引。

`nums[index]`可以和`nums[index-1]`相同，不可以和`nums[index-2]`以及更前面的数相同。因此不需要判断`nums[i]`和`nums[index-1]`的关系，只需要判断`nums[i] != nums[index-2]`就可以将`i`作为新的`index`。

### 解法

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() < 3) return nums.size();
        int index = 2;
        for (int i = 2; i < nums.size(); i++) {
            if (nums[i] != nums[index-2]) {
                nums[index++] = nums[i];
            }
        }
        return index;
    }
};
```





## 3. [[33]搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

### 题目描述

整数数组`nums`按升序排列，数组中的值 互不相同 。

在传递给函数之前，`nums`在预先未知的某个下标`k（0 <= k < nums.length）`上进行了 旋转，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 从 0 开始 计数）。例如，`[0,1,2,4,5,6,7]`在下标`3`处经旋转后可能变为`[4,5,6,7,0,1,2]`。

给你 旋转后 的数组`nums`和一个整数`target`，如果`nums`中存在这个目标值`target`，则返回它的下标，否则返回`-1`。

示例 1：

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```


示例 2：

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

示例 3：

```
输入：nums = [1], target = 0
输出：-1
```



## 4.[[81]搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

### 题目描述

已知存在一个按非降序排列的整数数组`nums`，数组中的值不必互不相同。

在传递给函数之前，`nums` 在预先未知的某个下标` k（0 <= k < nums.length）`上进行了 旋转 ，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 从 0 开始 计数）。例如，` [0,1,2,4,4,4,5,6,6,7]` 在下标 `5` 处经旋转后可能变为 `[4,5,6,6,7,0,1,2,4,4] `。

给你 旋转后 的数组 `nums` 和一个整数 `target`，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 `nums` 中存在这个目标值` target `，则返回 `true `，否则返回` false `。

示例 1：

```
输入：nums = [2,5,6,0,0,1,2], target = 0
输出：true
```


示例 2：

```
输入：nums = [2,5,6,0,0,1,2], target = 3
输出：false
```

## 5.[[4]寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

### 题目描述

给定两个大小分别为 `m `和` n `的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 `O(log (m+n))` 。

示例 1：

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```


示例 2：

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```


示例 3：

```
输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
```


示例 4：

```
输入：nums1 = [], nums2 = [1]
输出：1.00000
```


示例 5：

```
输入：nums1 = [2], nums2 = []
输出：2.00000
```

## 6.[[128]最长连继序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

### 题目描述

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n) `的算法解决此问题。

示例 1：

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```


示例 2：

```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

## 7.[[1]两数之和](https://leetcode-cn.com/problems/two-sum/)

### 题目描述

给定一个整数数组 `nums` 和一个整数目标值` target`，请你在该数组中找出 和为目标值 `target ` 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

示例 1：

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```


示例 2：

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```


示例 3：

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

## 8.[[15]三数之和](https://leetcode-cn.com/problems/3sum/)

### 题目描述

给你一个包含 `n` 个整数的数组 `nums`，判断 `nums `中是否存在三个元素 *a，b，c* ，使得*a + b + c* = 0 ？请你找出所有和为 `0 `且不重复的三元组。

**注意**：答案中不可以包含重复的三元组。

示例 1：

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```


示例 2：

```
输入：nums = []
输出：[]
```


示例 3：

```
输入：nums = [0]
输出：[]
```

## 9.[[16]最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

### 题目描述

给你一个长度为 `n` 的整数数组 `nums `和 一个目标值 `target`。请你从 `nums `中选出三个整数，使它们的和与 `target `最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。 

示例 1：

```
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```


示例 2：

```
输入：nums = [0,0,0], target = 1
输出：0
```

## 10.[[18]四数之和](https://leetcode-cn.com/problems/4sum/)

### 题目描述

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]] `（若两个四元组元素一一对应，则认为两个四元组重复）：

`0 <= a, b, c, d < n`
`a、b、c `和 `d `互不相同
`nums[a] + nums[b] + nums[c] + nums[d] == target`
你可以按 **任意顺序** 返回答案 。

 

示例 1：

```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```


示例 2：

```
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

## 11.[[27]移除元素](https://leetcode-cn.com/problems/remove-element/)

### 题目描述

给你一个数组 `nums `和一个值 `val`，你需要**原地** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1) `额外空间并 **原地 修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1：

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```


示例 2：

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

## 12.[[31]下一个排列](https://leetcode-cn.com/problems/next-permutation/)

### 题目描述

实现获取 **下一个排列** 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 **原地** 修改，只允许使用额外常数空间。

 

示例 1：

```
输入：nums = [1,2,3]
输出：[1,3,2]
```


示例 2：

```
输入：nums = [3,2,1]
输出：[1,2,3]
```


示例 3：

```
输入：nums = [1,1,5]
输出：[1,5,1]
```


示例 4：

```
输入：nums = [1]
输出：[1]
```

## 13.[[60]排列序列](https://leetcode-cn.com/problems/permutation-sequence/)

### 题目描述

给出集合 `[1,2,3,...,n]`，其所有元素共有 `n! `种排列。

按大小顺序列出所有排列情况，并一一标记，当 `n = 3` 时, 所有排列如下：

1.`"123"`
2.`"132"`
3.`"213"`
4.`"231"`
5.`"312"`
6.`"321"`
给定` n `和 `k`，返回第 `k `个排列。

示例 1：

```
输入：n = 3, k = 3
输出："213"
```


示例 2：

```
输入：n = 4, k = 9
输出："2314"
```


示例 3：

```
输入：n = 3, k = 1
输出："123"
```

### 思路

集合$$\{1,2,3，…，n\} $$的全排列有$$n!$$种，

康托展开可以实现按字典序排序的序列与自然数之间相互对应的双射

$$k-1=a_{n}*(n-1)!+a_(n-1)*(n-2)!+....+a_1*0!$$



## 14.[[36]有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

### 题目描述

请你判断一个 `9 x 9 `的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

数字 `1-9 `在每一行只能出现一次。
数字 `1-9` 在每一列只能出现一次。
数字` 1-9 `在每一个以粗实线分隔的 `3x3 `宫内只能出现一次。（请参考示例图）

**注意：**

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
空白格用` '.' `表示。

示例1：

![avatar](E:\markdown_files\leetcode_soulmachine\screen_shots\leetcode36.PNG)

```
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true
```

示例2：

```
输入：board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```





## 15.[[42]接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

### 题目描述

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

## 16.[[48]旋转图像](https://leetcode-cn.com/problems/rotate-image/)

### 题目描述

给定一个 `n × n` 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 **原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

## 17.[[66]加一](https://leetcode-cn.com/problems/plus-one/)

### 题目描述

给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。

你可以假设除了整数 `0` 之外，这个整数不会以零开头。

示例 1：

```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```


示例 2：

```
输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
```


示例 3：

```
输入：digits = [0]
输出：[1]
```

## 18.[[70]爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

### 题目描述

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或` 2 `个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定` n` 是一个正整数。

示例 1：

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。

1.  1 阶 + 1 阶
2.  2 阶
```




示例 2：

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。

1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

## 19.[[89]格雷编码](https://leetcode-cn.com/problems/gray-code/)

### 题目描述

**n 位格雷码序列** 是一个由$ 2^{n}$个整数组成的序列，其中：

- 每个整数都在范围 $[0, 2^{n}-1]$内（含 $0$和 $2^{n}-1$）
- 第一个整数是 $n$
- 一个整数在序列中出现 **不超过一次**
- 每对 **相邻** 整数的二进制表示 **恰好一位不同** ，且

- **第一个** 和 **最后一个** 整数的二进制表示 **恰好一位不同**

给你一个整数` n` ，返回任一有效的 **n 位格雷码序列** 。

示例 1：

```
输入：n = 2
输出：[0,1,3,2]
解释：
[0,1,3,2] 的二进制表示是 [00,01,11,10] 。

- 00 和 01 有一位不同
- 01 和 11 有一位不同
- 11 和 10 有一位不同
- 10 和 00 有一位不同
  [0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
- 00 和 10 有一位不同
- 10 和 11 有一位不同
- 11 和 01 有一位不同
- 01 和 00 有一位不同
```


示例 2：

```
输入：n = 1
输出：[0,1]
```

## 20.[[73]矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)

### 题目描述

给定一个 *`m x n`* 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**

## 21.[[134]加油站](https://leetcode-cn.com/problems/gas-station/)

### 题目描述

在一条环路上有` N` 个加油站，其中第 `i `个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第` i `个加油站开往第 `i+1 `个加油站需要消耗汽油` cost[i] `升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

示例 1:

```
输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```


示例 2:

```
输入: 
gas  = [2,3,4]
cost = [3,4,3]

输出: -1

解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。
```





