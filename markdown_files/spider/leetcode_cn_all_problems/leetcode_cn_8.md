# 801.使序列递增的最小交换次数
[https://leetcode-cn.com/problems/minimum-swaps-to-make-sequences-increasing](https://leetcode-cn.com/problems/minimum-swaps-to-make-sequences-increasing) 
## 原题
我们有两个长度相等且不为空的整型数组 `nums1` 和 `nums2` 。在一次操作中，我们可以交换 `nums1[i]` 和 `nums2[i]` 的元素。
- 例如，如果 `nums1 = [1,2,3,<u>8</u>]` ， `nums2 =[5,6,7,<u>4</u>]` ，你可以交换 `i = 3` 处的元素，得到 `nums1 =[1,2,3,4]` 和 `nums2 =[5,6,7,8]` 。
返回 *使 `nums1` 和 `nums2` **严格递增** 所需操作的最小次数* 。

数组 `arr` **严格递增** 且 `arr[0] < arr[1] < arr[2] < ... < arr[arr.length - 1]` 。

<b>注意：</b>
- 用例保证可以实现操作。
 

 **示例 1:** 

```

输入: nums1 = [1,3,5,4], nums2 = [1,2,3,7]
输出: 1
解释: 
交换 A[3] 和 B[3] 后，两个数组如下:
A = [1, 3, 5, 7] ， B = [1, 2, 3, 4]
两个数组均为严格递增的。
```
 **示例 2:** 

```

输入: nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9]
输出: 1

```
 

 **提示:** 
-  `2 <= nums1.length <= 10^5` 
-  `nums2.length == nums1.length` 
-  `0 <= nums1[i], nums2[i] <= 2 * 10^5` 
 
**标签**
`数组` `动态规划` 


## 
```python

```
>
# 802.找到最终的安全状态
[https://leetcode-cn.com/problems/find-eventual-safe-states](https://leetcode-cn.com/problems/find-eventual-safe-states) 
## 原题
在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。

对于一个起始节点，如果从该节点出发， **无论每一步选择沿哪条有向边行走** ，最后必然在有限步内到达终点，则将该起始节点称作是 **安全** 的。

返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 **升序** 排列。

该有向图有 `n` 个节点，按 `0` 到 `n - 1` 编号，其中 `n` 是 `graph` 的节点数。图以下述形式给出： `graph[i]` 是编号 `j` 节点的一个列表，满足 `(i, j)` 是图的一条有向边。

 
 **示例 1：** 
<img alt="Illustration of graph" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png" style="height: 171px; width: 600px;" />
```

输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]]
输出：[2,4,5,6]
解释：示意图如上。

```
 **示例 2：** 

```

输入：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
输出：[4]

```
 

 **提示：** 
-  `n == graph.length` 
-  `1 <= n <= 10^4` 
-  `0 <= graph[i].length <= n` 
-  `graph[i]` 按严格递增顺序排列。
- 图中可能包含自环。
- 图中边的数目在范围 `[1, 4 * 10^4]` 内。
 
**标签**
`深度优先搜索` `广度优先搜索` `图` `拓扑排序` 


## 
```python

```
>
# 803.打砖块
[https://leetcode-cn.com/problems/bricks-falling-when-hit](https://leetcode-cn.com/problems/bricks-falling-when-hit) 
## 原题
有一个 `m x n` 的二元网格<meta charset="UTF-8" /> `grid` ，其中 `1` 表示砖块， `0` 表示空白。砖块 **稳定** （不会掉落）的前提是：
- 一块砖直接连接到网格的顶部，或者
- 至少有一块相邻（4 个方向之一）砖块 **稳定** 不会掉落时
给你一个数组 `hits` ，这是需要依次消除砖块的位置。每当消除 `hits[i] = (rowi, coli)` 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而 **掉落** 。一旦砖块掉落，它会 **立即** 从网格 `grid` 中消失（即，它不会落在其他稳定的砖块上）。

返回一个数组 `result` ，其中 `result[i]` 表示第 `i` 次消除操作对应掉落的砖块数目。

 **注意** ，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。

 

 **示例 1：** 

```

输入：grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]
输出：[2]
解释：网格开始为：
[[1,0,0,0]，
 [1,1,1,0]]
消除 (1,0) 处加粗的砖块，得到网格：
[[1,0,0,0]
 [0,1,1,0]]
两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：
[[1,0,0,0],
 [0,0,0,0]]
因此，结果为 [2] 。

```
 **示例 2：** 

```

输入：grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]
输出：[0,0]
解释：网格开始为：
[[1,0,0,0],
 [1,1,0,0]]
消除 (1,1) 处加粗的砖块，得到网格：
[[1,0,0,0],
 [1,0,0,0]]
剩下的砖都很稳定，所以不会掉落。网格保持不变：
[[1,0,0,0], 
 [1,0,0,0]]
接下来消除 (1,0) 处加粗的砖块，得到网格：
[[1,0,0,0],
 [0,0,0,0]]
剩下的砖块仍然是稳定的，所以不会有砖块掉落。
因此，结果为 [0,0] 。
```
 

 **提示：** 
-  `m == grid.length` 
-  `n == grid[i].length` 
-  `1 <= m, n <= 200` 
-  `grid[i][j]` 为 `0` 或 `1` 
-  `1 <= hits.length <= 4 * 10^4` 
-  `hits[i].length == 2` 
-  `0 <= x<sub>i </sub><= m - 1` 
-  `0 <= y<sub>i</sub> <= n - 1` 
- 所有 `(x<sub>i</sub>, y<sub>i</sub>)` 互不相同
 
**标签**
`并查集` `数组` `矩阵` 


## 
```python

```
>
# 804.唯一摩尔斯密码词
[https://leetcode-cn.com/problems/unique-morse-code-words](https://leetcode-cn.com/problems/unique-morse-code-words) 
## 原题
国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如:
-  `'a'` 对应 `".-"` ，
-  `'b'` 对应 `"-..."` ，
-  `'c'` 对应 `"-.-."` ，以此类推。
为了方便，所有 `26` 个英文字母的摩尔斯密码表如下：

```

[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
```
给你一个字符串数组 `words` ，每个单词可以写成每个字母对应摩尔斯密码的组合。
- 例如， `"cab"` 可以写成 `"-.-..--..."` ，(即 `"-.-."` + `".-"` + `"-..."` 字符串的结合)。我们将这样一个连接过程称作 **单词翻译** 。
对 **** `words` 中所有单词进行单词翻译，返回不同 **单词翻译** 的数量。

 

 **示例 1：** 

```

输入: words = ["gin", "zen", "gig", "msg"]
输出: 2
解释: 
各单词翻译如下:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

共有 2 种不同翻译, "--...-." 和 "--...--.".

```
 **示例 2：** 

```

输入：words = ["a"]
输出：1

```
 

 **提示：** 
-  `1 <= words.length <= 100` 
-  `1 <= words[i].length <= 12` 
-  `words[i]` 由小写英文字母组成
 
**标签**
`数组` `哈希表` `字符串` 


## 
```python

```
>
# 805.数组的均值分割
[https://leetcode-cn.com/problems/split-array-with-same-average](https://leetcode-cn.com/problems/split-array-with-same-average) 
## 原题
给定你一个整数数组<meta charset="UTF-8" /> `nums` 

我们要将<meta charset="UTF-8" /> `nums` 数组中的每个元素移动到 `A` 数组 或者 `B` 数组中，使得 `A` 数组和<meta charset="UTF-8" /> `B` 数组不为空，并且<meta charset="UTF-8" /> `average(A) == average(B)` 。

如果可以完成则返回 `true` ， 否则返回 `false` 。

 **注意：** 对于数组<meta charset="UTF-8" /> `arr` , <meta charset="UTF-8" /> `average(arr)` 是<meta charset="UTF-8" /> `arr` 的所有元素除以<meta charset="UTF-8" /> `arr` 长度的和。

 

 **示例 1:** 

```

输入: nums = [1,2,3,4,5,6,7,8]
输出: true
解释: 我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。

```
 **示例 2:** 

```

输入: nums = [3,1]
输出: false

```
 

 **提示:** 
-  `1 <= nums.length <= 30` 
-  `0 <= nums[i] <= 10^4` 
 
**标签**
`位运算` `数组` `数学` `动态规划` `状态压缩` 


## 
```python

```
>
# 806.写字符串需要的行数
[https://leetcode-cn.com/problems/number-of-lines-to-write-string](https://leetcode-cn.com/problems/number-of-lines-to-write-string) 
## 原题
我们要把给定的字符串 `S` 从左到右写到每一行上，每一行的最大宽度为100个单位，如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组 `widths` ，这个数组 widths[0] 代表 ';a'; 需要的单位， widths[1] 代表 ';b'; 需要的单位，...， widths[25] 代表 ';z'; 需要的单位。

现在回答两个问题：至少多少行能放下 `S` ，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为2的整数列表返回。

```

示例 1:
输入: 
widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "abcdefghijklmnopqrstuvwxyz"
输出: [3, 60]
解释: 
所有的字符拥有相同的占用单位10。所以书写所有的26个字母，
我们需要2个整行和占用60个单位的一行。

```
```

示例 2:
输入: 
widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "bbbcccdddaaa"
输出: [2, 4]
解释: 
除去字母';a';所有的字符都是相同的单位10，并且字符串 "bbbcccdddaa" 将会覆盖 9 * 10 + 2 * 4 = 98 个单位.
最后一个字母 ';a'; 将会被写到第二行，因为第一行只剩下2个单位了。
所以，这个答案是2行，第二行有4个单位宽度。

```
 

 **注:** 
- 字符串 `S` 的长度在 [1, 1000] 的范围。
-  `S` 只包含小写字母。
-  `widths` 是长度为 `26` 的数组。
-  `widths[i]` 值的范围在 `[2, 10]` 。
 
**标签**
`数组` `字符串` 


## 
```python

```
>
# 807.保持城市天际线
[https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline](https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline) 
## 原题
给你一座由 `n x n` 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 **0** 开始的 `n x n` 整数矩阵 `grid` ，其中 `grid[r][c]` 表示坐落于 `r` 行 `c` 列的建筑物的 **高度** 。

城市的 **天际线** 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 **天际线** 可能不同。

我们被允许为 **任意数量的建筑物** 的高度增加 **任意增量（不同建筑物的增量可能不同）** 。 高度为 `0` 的建筑物的高度也可以增加。然而，增加的建筑物高度 **不能影响** 从任何主要方向观察城市得到的 **天际线** 。

在 **不改变** 从任何主要方向观测到的城市 **天际线** 的前提下，返回建筑物可以增加的 **最大高度增量总和** 。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/21/807-ex1.png" style="width: 700px; height: 603px;" />
```

输入：grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
输出：35
解释：建筑物的高度如上图中心所示。
用红色绘制从不同方向观看得到的天际线。
在不影响天际线的情况下，增加建筑物的高度：
gridNew = [ [8, 4, 8, 7],
            [7, 4, 7, 7],
            [9, 4, 8, 7],
            [3, 3, 3, 3] ]

```
 **示例 2：** 

```

输入：grid = [[0,0,0],[0,0,0],[0,0,0]]
输出：0
解释：增加任何建筑物的高度都会导致天际线的变化。

```
 

 **提示：** 
-  `n == grid.length` 
-  `n == grid[r].length` 
-  `2 <= n <= 50` 
-  `0 <= grid[r][c] <= 100` 
 
**标签**
`贪心` `数组` `矩阵` 


## 
```python

```
>
# 808.分汤
[https://leetcode-cn.com/problems/soup-servings](https://leetcode-cn.com/problems/soup-servings) 
## 原题
有 **A 和 B 两种类型** 的汤。一开始每种类型的汤有 `n` 毫升。有四种分配操作：
- 提供 `100ml` 的 **汤A** 和 `0ml` 的 **汤B** 。
- 提供 `75ml` 的 **汤A** 和 `25ml` 的 **汤B** 。
- 提供 `50ml` 的 **汤A** 和 `50ml` 的 **汤B** 。
- 提供 `25ml` 的 **汤A** 和 `75ml` 的 **汤B** 。
当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 `0.25` 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。

 **注意** 不存在先分配 `100` ml **汤B** 的操作。

需要返回的值： **汤A** 先分配完的概率 + **汤A和汤B** 同时分配完的概率 / 2。返回值在正确答案 `10^-5` 的范围内将被认为是正确的。

 

 **示例 1:** 

```

输入: n = 50
输出: 0.62500
解释:如果我们选择前两个操作，A 首先将变为空。
对于第三个操作，A 和 B 会同时变为空。
对于第四个操作，B 首先将变为空。
所以 A 变为空的总概率加上 A 和 B 同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。

```
 **示例 2:** 

```

输入: n = 100
输出: 0.71875

```
 

 **提示:** 
-  `0 <= n <= 10^9` ​​​​​​​
 
**标签**
`数学` `动态规划` `概率与统计` 


## 
```python

```
>
# 809.情感丰富的文字
[https://leetcode-cn.com/problems/expressive-words](https://leetcode-cn.com/problems/expressive-words) 
## 原题
有时候人们会用重复写一些字母来表示额外的感受，比如 `"hello" -> "heeellooo"` , `"hi" -> "hiii"` 。我们将相邻字母都相同的一串字符定义为相同字母组，例如："h", "eee", "ll", "ooo"。

对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母  `c`  ），然后往其中添加相同的字母  `c`  使其长度达到 3 或以上。

例如，以 "hello" 为例，我们可以对字母组 "o" 扩张得到 "hellooo"，但是无法以同样的方法得到 "helloo" 因为字母组 "oo" 长度小于 3。此外，我们可以进行另一种扩张 "ll" -> "lllll" 以获得 "helllllooo"。如果  `S = "helllllooo"` ，那么查询词 "hello" 是可扩张的，因为可以对它执行这两种扩张操作使得  `query = "hello" -> "hellooo" -> "helllllooo" = S` 。

输入一组查询单词，输出其中可扩张的单词数量。

 

 **示例：** 

```

输入： 
S = "heeellooo"
words = ["hello", "hi", "helo"]
输出：1
解释：
我们能通过扩张 "hello" 的 "e" 和 "o" 来得到 "heeellooo"。
我们不能通过扩张 "helo" 来得到 "heeellooo" 因为 "ll" 的长度小于 3 。

```
 

 **提示：** 
-  `0 <= len(S) <= 100` 。
-  `0 <= len(words) <= 100` 。
-  `0 <= len(words[i]) <= 100` 。
-  `S`  和所有在  `words`  中的单词都只由小写字母组成。
 
**标签**
`数组` `双指针` `字符串` 


## 
```python

```
>
# 810.黑板异或游戏
[https://leetcode-cn.com/problems/chalkboard-xor-game](https://leetcode-cn.com/problems/chalkboard-xor-game) 
## 原题
黑板上写着一个非负整数数组 `nums[i]` 。

Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 `0` 的话，当前玩家游戏失败。 另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 `0` 。

并且，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 `0` ，这个玩家获胜。

假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 `true` 。

 

 **示例 1：** 

```

输入: nums = [1,1,2]
输出: false
解释: 
Alice 有两个选择: 擦掉数字 1 或 2。
如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。
如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。

```
 **示例 2:** 

```

输入: nums = [0,1]
输出: true

```
 **示例 3:** 

```

输入: nums = [1,2,3]
输出: true

```
 

 **提示：** 
-  `1 <= nums.length <= 1000` 
-  `0 <= nums[i] < 2^16` 
 
**标签**
`位运算` `脑筋急转弯` `数组` `数学` `博弈` 


## 
```python

```
>
# 811.子域名访问计数
[https://leetcode-cn.com/problems/subdomain-visit-count](https://leetcode-cn.com/problems/subdomain-visit-count) 
## 原题
网站域名 `"discuss.leetcode.com"` 由多个子域名组成。顶级域名为 `"com"` ，二级域名为 `"leetcode.com"` ，最低一级为 `"discuss.leetcode.com"` 。当访问域名 `"discuss.leetcode.com"` 时，同时也会隐式访问其父域名 `"leetcode.com"` 以及 `"com"` 。

 **计数配对域名** 是遵循 `"rep d1.d2.d3"` 或 `"rep d1.d2"` 格式的一个域名表示，其中 `rep` 表示访问域名的次数， `d1.d2.d3` 为域名本身。
- 例如， `"9001 discuss.leetcode.com"` 就是一个 **计数配对域名** ，表示 `discuss.leetcode.com` 被访问了 `9001` 次。
给你一个 **计数配对域名** 组成的数组 `cpdomains` ，解析得到输入中每个子域名对应的 **计数配对域名** ，并以数组形式返回。可以按 **任意顺序** 返回答案。

 

 **示例 1：** 

```

输入：cpdomains = ["9001 discuss.leetcode.com"]
输出：["9001 leetcode.com","9001 discuss.leetcode.com","9001 com"]
解释：例子中仅包含一个网站域名："discuss.leetcode.com"。
按照前文描述，子域名 "leetcode.com" 和 "com" 都会被访问，所以它们都被访问了 9001 次。
```
 **示例 2：** 

```

输入：cpdomains = ["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"]
输出：["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"]
解释：按照前文描述，会访问 "google.mail.com" 900 次，"yahoo.com" 50 次，"intel.mail.com" 1 次，"wiki.org" 5 次。
而对于父域名，会访问 "mail.com" 900 + 1 = 901 次，"com" 900 + 50 + 1 = 951 次，和 "org" 5 次。

```
 

 **提示：** 
-  `1 <= cpdomain.length <= 100` 
-  `1 <= cpdomain[i].length <= 100` 
-  `cpdomain[i]` 会遵循 `"rep<sub>i</sub> d1<sub>i</sub>.d2<sub>i</sub>.d3<sub>i</sub>"` 或 `"rep<sub>i</sub> d1<sub>i</sub>.d2<sub>i</sub>"` 格式
-  `rep<sub>i</sub>` 是范围 `[1, 10^4]` 内的一个整数
-  `d1<sub>i</sub>` 、 `d2<sub>i</sub>` 和 `d3<sub>i</sub>` 由小写英文字母组成
 
**标签**
`数组` `哈希表` `字符串` `计数` 


## 
```python

```
>
# 812.最大三角形面积
[https://leetcode-cn.com/problems/largest-triangle-area](https://leetcode-cn.com/problems/largest-triangle-area) 
## 原题
给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。

```

示例:
输入: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]
输出: 2
解释: 
这五个点如下图所示。组成的橙色三角形是最大的，面积为2。

```
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/04/1027.png" style="height:328px; width:400px" />

 **注意:** 
-  `3 <= points.length <= 50` .
- 不存在重复的点。
-  `-50 <= points[i][j] <= 50` .
- 结果误差值在 `10^-6` 以内都认为是正确答案。
 
**标签**
`几何` `数组` `数学` 


## 
```python

```
>
# 813.最大平均值和的分组
[https://leetcode-cn.com/problems/largest-sum-of-averages](https://leetcode-cn.com/problems/largest-sum-of-averages) 
## 原题
给定数组 `nums` 和一个整数 `k` 。我们将给定的数组 `nums` 分成 **最多** `k` 个相邻的非空子数组 。 **分数** 由每个子数组内的平均值的总和构成。

注意我们必须使用 `nums` 数组中的每一个数进行分组，并且分数不一定需要是整数。

返回我们所能得到的最大 **分数** 是多少。答案误差在 `10^-6` 内被视为是正确的。

 

 **示例 1:** 

```

输入: nums = [9,1,2,3,9], k = 3
输出: 20.00000
解释: 
nums 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20. 
我们也可以把 nums 分成[9, 1], [2], [3, 9]. 
这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.

```
 **示例 2:** 

```

输入: nums = [1,2,3,4,5,6,7], k = 4
输出: 20.50000

```
 

 **提示:** 
-  `1 <= nums.length <= 100` 
-  `1 <= nums[i] <= 10^4` 
-  `1 <= k <= nums.length` 
 
**标签**
`数组` `动态规划` 


## 
```python

```
>
# 814.二叉树剪枝
[https://leetcode-cn.com/problems/binary-tree-pruning](https://leetcode-cn.com/problems/binary-tree-pruning) 
## 原题
给你二叉树的根结点 `root` ，此外树的每个结点的值要么是 `0` ，要么是 `1` 。

返回移除了所有不包含 `1` 的子树的原二叉树。

节点 `node` 的子树为 `node` 本身加上所有 `node` 的后代。

 

 **示例 1：** 
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png" style="width: 500px; height: 140px;" />
```

输入：root = [1,null,0,0,1]
输出：[1,null,0,null,1]
解释：
只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。

```
 **示例 2：** 
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_1.png" style="width: 500px; height: 115px;" />
```

输入：root = [1,0,1,0,0,0,1]
输出：[1,null,1,null,1]

```
 **示例 3：** 
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/05/1028.png" style="width: 500px; height: 134px;" />
```

输入：root = [1,1,0,1,1,0,1,0]
输出：[1,1,0,1,1,null,1]

```
 

 **提示：** 
- 树中节点的数目在范围 `[1, 200]` 内
-  `Node.val` 为 `0` 或 `1` 
 
**标签**
`树` `深度优先搜索` `二叉树` 


## 
```python

```
>
# 815.公交路线
[https://leetcode-cn.com/problems/bus-routes](https://leetcode-cn.com/problems/bus-routes) 
## 原题
给你一个数组 `routes` ，表示一系列公交线路，其中每个 `routes[i]` 表示一条公交线路，第 `i` 辆公交车将会在上面循环行驶。
- 例如，路线 `routes[0] = [1, 5, 7]` 表示第 `0` 辆公交车会一直按序列 `1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...` 这样的车站路线行驶。
现在从 `source` 车站出发（初始时不在公交车上），要前往 `target` 车站。 期间仅可乘坐公交车。

求出 **最少乘坐的公交车数量** 。如果不可能到达终点车站，返回 `-1` 。

 

 **示例 1：** 

```

输入：routes = [[1,2,7],[3,6,7]], source = 1, target = 6
输出：2
解释：最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。 

```
 **示例 2：** 

```

输入：routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
输出：-1

```
 

 **提示：** 
-  `1 <= routes.length <= 500` .
-  `1 <= routes[i].length <= 10^5` 
-  `routes[i]` 中的所有值 **互不相同** 
-  `sum(routes[i].length) <= 10^5` 
-  `0 <= routes[i][j] < 10^6` 
-  `0 <= source, target < 10^6` 
 
**标签**
`广度优先搜索` `数组` `哈希表` 


## 
```python

```
>
# 816.模糊坐标
[https://leetcode-cn.com/problems/ambiguous-coordinates](https://leetcode-cn.com/problems/ambiguous-coordinates) 
## 原题
我们有一些二维坐标，如 `"(1, 3)"` 或 `"(2, 0.5)"` ，然后我们移除所有逗号，小数点和空格，得到一个字符串 `S` 。返回所有可能的原始字符串到一个列表中。

原始的坐标表示法不会存在多余的零，所以不会出现类似于"00", "0.0", "0.00", "1.0", "001", "00.01"或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现“.1”形式的数字。

最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。

 

```

示例 1:
输入: "(123)"
输出: ["(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"]

```
```

示例 2:
输入: "(00011)"
输出:  ["(0.001, 1)", "(0, 0.011)"]
解释: 
0.0, 00, 0001 或 00.01 是不被允许的。

```
```

示例 3:
输入: "(0123)"
输出: ["(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"]

```
```

示例 4:
输入: "(100)"
输出: [(10, 0)]
解释: 
1.0 是不被允许的。

```
 

 **提示:** 
-  `4 <= S.length <= 12` .
-  `S[0]` = "(", `S[S.length - 1]` = ")", 且字符串 `S` 中的其他元素都是数字。
 

 
**标签**
`字符串` `回溯` 


## 
```python

```
>
# 817.链表组件
[https://leetcode-cn.com/problems/linked-list-components](https://leetcode-cn.com/problems/linked-list-components) 
## 原题
给定链表头结点 `head` ，该链表上的每个结点都有一个 **唯一的整型值** 。同时给定列表 `nums` ，该列表是上述链表中整型值的一个子集。

返回列表 `nums` 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 `nums` 中）构成的集合。

 

 **示例 1：** 

<img src="https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom1.jpg" />

```

输入: head = [0,1,2,3], nums = [0,1,3]
输出: 2
解释: 链表中,0 和 1 是相连接的，且 nums 中不包含 2，所以 [0, 1] 是 nums 的一个组件，同理 [3] 也是一个组件，故返回 2。
```
 **示例 2：** 

 **** <img src="https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom2.jpg" />

```

输入: head = [0,1,2,3,4], nums = [0,3,1,4]
输出: 2
解释: 链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。
```
 

 **提示：** 
- 链表中节点数为 `n` 
-  `1 <= n <= 10^4` 
-  `0 <= Node.val < n` 
-  `Node.val` 中所有值 **不同** 
-  `1 <= nums.length <= n` 
-  `0 <= nums[i] < n` 
-  `nums` 中所有值 **不同** 
 
**标签**
`哈希表` `链表` 


## 
```python

```
>
# 818.赛车
[https://leetcode-cn.com/problems/race-car](https://leetcode-cn.com/problems/race-car) 
## 原题
你的赛车可以从位置 `0` 开始，并且速度为 `+1` ，在一条无限长的数轴上行驶。赛车也可以向负方向行驶。赛车可以按照由加速指令 `'A'` 和倒车指令 `'R'` 组成的指令序列自动行驶。

- 当收到指令 `'A'` 时，赛车这样行驶：
	
-  `position += speed` 
-  `speed *= 2` 
	
	
- 当收到指令 `'R'` 时，赛车这样行驶：
	
- 如果速度为正数，那么 `speed = -1` 
- 否则 `speed = 1` 
	
	当前所处位置不变。
例如，在执行指令 `"AAR"` 后，赛车位置变化为 `0 --> 1 --> 3 --> 3` ，速度变化为 `1 --> 2 --> 4 --> -1` 。

给你一个目标位置 `target` ，返回能到达目标位置的最短指令序列的长度。

 

 **示例 1：** 

```

输入：target = 3
输出：2
解释：
最短指令序列是 "AA" 。
位置变化 0 --> 1 --> 3 。

```
 **示例 2：** 

```

输入：target = 6
输出：5
解释：
最短指令序列是 "AAARA" 。
位置变化 0 --> 1 --> 3 --> 7 --> 7 --> 6 。

```
 

 **提示：** 
-  `1 <= target <= 10^4` 
 
**标签**
`动态规划` 


## 
```python

```
>
# 819.最常见的单词
[https://leetcode-cn.com/problems/most-common-word](https://leetcode-cn.com/problems/most-common-word) 
## 原题
给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。

题目保证至少有一个词不在禁用列表中，而且答案唯一。

禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。

 

 **示例：** 

```
输入: 
paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
banned = ["hit"]
输出: "ball"
解释: 
"hit" 出现了3次，但它是一个禁用的单词。
"ball" 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。 
注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 "ball,"）， 
"hit"不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。

```
 

 **提示：** 
-  `1 <= 段落长度 <= 1000` 
-  `0 <= 禁用单词个数 <= 100` 
-  `1 <= 禁用单词长度 <= 10` 
- 答案是唯一的, 且都是小写字母 (即使在 `paragraph` 里是大写的，即使是一些特定的名词，答案都是小写的。)
-  `paragraph` 只包含字母、空格和下列标点符号 `!?';,;.` 
- 不存在没有连字符或者带有连字符的单词。
- 单词里只包含字母，不会出现省略号或者其他标点符号。
 
**标签**
`哈希表` `字符串` 


## 
```python

```
>
# 820.单词的压缩编码
[https://leetcode-cn.com/problems/short-encoding-of-words](https://leetcode-cn.com/problems/short-encoding-of-words) 
## 原题
单词数组  `words` 的 **有效编码** 由任意助记字符串 `s` 和下标数组 `indices` 组成，且满足：
-  `words.length == indices.length` 
- 助记字符串 `s` 以 `'#'` 字符结尾
- 对于每个下标 `indices[i]` ， `s` 的一个从 `indices[i]` 开始、到下一个 `'#'` 字符结束（但不包括 `'#'` ）的 **子字符串** 恰好与 `words[i]` 相等
给你一个单词数组  `words` ，返回成功对 `words` 进行编码的最小助记字符串 `s` 的长度 。

 

 **示例 1：** 

```

输入：words = ["time", "me", "bell"]
输出：10
解释：一组有效编码为 s = "time#bell#" 和 indices = [0, 2, 5] 。
words[0] = "time" ，s 开始于 indices[0] = 0 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"
words[1] = "me" ，s 开始于 indices[1] = 2 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"
words[2] = "bell" ，s 开始于 indices[2] = 5 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"

```
 **示例 2：** 

```

输入：words = ["t"]
输出：2
解释：一组有效编码为 s = "t#" 和 indices = [0] 。

```
 

 **提示：** 
-  `1 <= words.length <= 2000` 
-  `1 <= words[i].length <= 7` 
-  `words[i]` 仅由小写字母组成
 
**标签**
`字典树` `数组` `哈希表` `字符串` 


## 
```python

```
>
# 821.字符的最短距离
[https://leetcode-cn.com/problems/shortest-distance-to-a-character](https://leetcode-cn.com/problems/shortest-distance-to-a-character) 
## 原题
给你一个字符串 `s` 和一个字符 `c` ，且 `c` 是 `s` 中出现过的字符。

返回一个整数数组 `answer` ，其中 `answer.length == s.length` 且 `answer[i]` 是 `s` 中从下标 `i` 到离它 **最近** 的字符 `c` 的 **距离** 。

两个下标 `i` 和 `j` 之间的 **距离** 为 `abs(i - j)` ，其中 `abs` 是绝对值函数。

 

 **示例 1：** 

```

输入：s = "loveleetcode", c = "e"
输出：[3,2,1,0,1,0,0,1,2,2,1,0]
解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。
距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。
距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。
对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。
距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。

```
 **示例 2：** 

```

输入：s = "aaab", c = "b"
输出：[3,2,1,0]

```
 
 **提示：** 
-  `1 <= s.length <= 10^4` 
-  `s[i]` 和 `c` 均为小写英文字母
- 题目数据保证 `c` 在 `s` 中至少出现一次
 
**标签**
`数组` `双指针` `字符串` 


## 
```python

```
>
# 822.翻转卡片游戏
[https://leetcode-cn.com/problems/card-flipping-game](https://leetcode-cn.com/problems/card-flipping-game) 
## 原题
在桌子上有 `N` 张卡片，每张卡片的正面和背面都写着一个正数（正面与背面上的数有可能不一样）。

我们可以先翻转任意张卡片，然后选择其中一张卡片。

如果选中的那张卡片背面的数字 `X` 与任意一张卡片的正面的数字都不同，那么这个数字是我们想要的数字。

哪个数是这些想要的数字中最小的数（找到这些数中的最小值）呢？如果没有一个数字符合要求的，输出 0。

其中, `fronts[i]` 和 `backs[i]` 分别代表第 `i` 张卡片的正面和背面的数字。

如果我们通过翻转卡片来交换正面与背面上的数，那么当初在正面的数就变成背面的数，背面的数就变成正面的数。

 **示例：** 

```

输入：fronts = [1,2,4,4,7], backs = [1,3,4,1,3]
输出：2
解释：假设我们翻转第二张卡片，那么在正面的数变成了 [1,3,4,4,7] ， 背面的数变成了 [1,2,4,1,3]。
接着我们选择第二张卡片，因为现在该卡片的背面的数是 2，2 与任意卡片上正面的数都不同，所以 2 就是我们想要的数字。
```
 

 **提示：** 
-  `1 <= fronts.length == backs.length <= 1000` 
-  `1 <= fronts[i] <= 2000` 
-  `1 <= backs[i] <= 2000` 
 
**标签**
`数组` `哈希表` 


## 
```python

```
>
# 823.带因子的二叉树
[https://leetcode-cn.com/problems/binary-trees-with-factors](https://leetcode-cn.com/problems/binary-trees-with-factors) 
## 原题
给出一个含有不重复整数元素的数组 `arr` ，每个整数 `arr[i]` 均大于 1。

用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。

满足条件的二叉树一共有多少个？答案可能很大，返回 **对** `10^9 + 7` **取余** 的结果。

 

 **示例 1:** 

```

输入: arr = [2, 4]
输出: 3
解释: 可以得到这些二叉树: [2], [4], [4, 2, 2]
```
 **示例 2:** 

```

输入: arr = [2, 4, 5, 10]
输出: 7
解释: 可以得到这些二叉树: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].
```
 

 **提示：** 
-  `1 <= arr.length <= 1000` 
-  `2 <= arr[i] <= 10^9` 
-  `arr` 中的所有值 **互不相同** 
 
**标签**
`数组` `哈希表` `动态规划` 


## 
```python

```
>
# 824.山羊拉丁文
[https://leetcode-cn.com/problems/goat-latin](https://leetcode-cn.com/problems/goat-latin) 
## 原题
给定一个由空格分割单词的句子 `S` 。每个单词只包含大写或小写字母。

我们要将句子转换为 *“Goat Latin”* （一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。

山羊拉丁文的规则如下：
- 如果单词以元音开头（a, e, i, o, u），在单词后添加 `"ma"` 。<br />
	例如，单词 `"apple"` 变为 `"applema"` 。
	<br />
- 如果单词以辅音字母开头（即非元音字母），移除第一个字符并将它放到末尾，之后再添加 `"ma"` 。<br />
	例如，单词 `"goat"` 变为 `"oatgma"` 。
	<br />
- 根据单词在句子中的索引，在单词最后添加与索引相同数量的字母 `';a';` ，索引从1开始。<br />
	例如，在第一个单词后添加 `"a"` ，在第二个单词后添加 `"aa"` ，以此类推。
返回将 `S` 转换为山羊拉丁文后的句子。

 **示例 1:** 

```

输入: "I speak Goat Latin"
输出: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"

```
 **示例 2:** 

```

输入: "The quick brown fox jumped over the lazy dog"
输出: "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"

```
 **说明:** 
-  `S` 中仅包含大小写字母和空格。单词间有且仅有一个空格。
-  `1 <= S.length <= 150` 。
 
**标签**
`字符串` 


## 
```python

```
>
# 825.适龄的朋友
[https://leetcode-cn.com/problems/friends-of-appropriate-ages](https://leetcode-cn.com/problems/friends-of-appropriate-ages) 
## 原题
在社交媒体网站上有 `n` 个用户。给你一个整数数组 `ages` ，其中 `ages[i]` 是第 `i` 个用户的年龄。

如果下述任意一个条件为真，那么用户 `x` 将不会向用户 `y` （ `x != y` ）发送好友请求：
-  `ages[y] <= 0.5 * ages[x] + 7` 
-  `ages[y] > ages[x]` 
-  `ages[y] > 100 &amp;&amp; ages[x] < 100` 
否则， `x` 将会向 `y` 发送一条好友请求。

注意，如果 `x` 向 `y` 发送一条好友请求， `y` 不必也向 `x` 发送一条好友请求。另外，用户不会向自己发送好友请求。

返回在该社交媒体网站上产生的好友请求总数。

 

 **示例 1：** 

```

输入：ages = [16,16]
输出：2
解释：2 人互发好友请求。

```
 **示例 2：** 

```

输入：ages = [16,17,18]
输出：2
解释：产生的好友请求为 17 -> 16 ，18 -> 17 。

```
 **示例 3：** 

```

输入：ages = [20,30,100,110,120]
输出：3
解释：产生的好友请求为 110 -> 100 ，120 -> 110 ，120 -> 100 。

```
 

 **提示：** 
-  `n == ages.length` 
-  `1 <= n <= 2 * 10^4` 
-  `1 <= ages[i] <= 120` 
 
**标签**
`数组` `双指针` `二分查找` `排序` 


## 
```python

```
>
# 826.安排工作以达到最大收益
[https://leetcode-cn.com/problems/most-profit-assigning-work](https://leetcode-cn.com/problems/most-profit-assigning-work) 
## 原题
你有 `n` 个工作和 `m` 个工人。给定三个数组： `difficulty` , `profit` 和 `worker` ，其中:
-  `difficulty[i]` 表示第 `i` 个工作的难度， `profit[i]` 表示第 `i` 个工作的收益。
-  `worker[i]` 是第 `i` 个工人的能力，即该工人只能完成难度小于等于 `worker[i]` 的工作。
每个工人 **最多** 只能安排 **一个** 工作，但是一个工作可以 **完成多次** 。
- 举个例子，如果 3 个工人都尝试完成一份报酬为 `$1` 的同样工作，那么总收益为 `$3` 。如果一个工人不能完成任何工作，他的收益为 `$0` 。
返回 *在把工人分配到工作岗位后，我们所能获得的最大利润* 。

 

 **示例 1：** 

```

输入: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
输出: 100 
解释: 工人被分配的工作难度是 [4,4,6,6] ，分别获得 [20,20,30,30] 的收益。
```
 **示例 2:** 

```

输入: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]
输出: 0
```
 

 **提示:** 
-  `n == difficulty.length` 
-  `n == profit.length` 
-  `m == worker.length` 
-  `1 <= n, m <= 10^4` 
-  `1 <= difficulty[i], profit[i], worker[i] <= 10^5` 
 
**标签**
`贪心` `数组` `双指针` `二分查找` `排序` 


## 
```python

```
>
# 827.最大人工岛
[https://leetcode-cn.com/problems/making-a-large-island](https://leetcode-cn.com/problems/making-a-large-island) 
## 原题
给你一个大小为 `n x n` 二进制矩阵 `grid` 。 **最多** 只能将一格  `0` 变成  `1` 。

返回执行此操作后， `grid` 中最大的岛屿面积是多少？

 **岛屿** 由一组上、下、左、右四个方向相连的  `1` 形成。

 

 **示例 1:** 

```

输入: grid = [[1, 0], [0, 1]]
输出: 3
解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。

```
 **示例 2:** 

```

输入: grid = [[1, 1], [1, 0]]
输出: 4
解释: 将一格0变成1，岛屿的面积扩大为 4。
```
 **示例 3:** 

```

输入: grid = [[1, 1], [1, 1]]
输出: 4
解释: 没有0可以让我们变成1，面积依然为 4。
```
 

 **提示：** 
-  `n == grid.length` 
-  `n == grid[i].length` 
-  `1 <= n <= 500` 
-  `grid[i][j]` 为 `0` 或 `1` 
 
**标签**
`深度优先搜索` `广度优先搜索` `并查集` `数组` `矩阵` 


## 
```python

```
>
# 828.统计子串中的唯一字符
[https://leetcode-cn.com/problems/count-unique-characters-of-all-substrings-of-a-given-string](https://leetcode-cn.com/problems/count-unique-characters-of-all-substrings-of-a-given-string) 
## 原题
我们定义了一个函数 `countUniqueChars(s)` 来统计字符串 `s` 中的唯一字符，并返回唯一字符的个数。

例如： `s = "LEETCODE"` ，则其中 `"L"` , `"T"` , `"C"` , `"O"` , `"D"` 都是唯一字符，因为它们只出现一次，所以 `countUniqueChars(s) = 5` 。

本题将会给你一个字符串 `s` ，我们需要返回 `countUniqueChars(t)` 的总和，其中 `t` 是 `s` 的子字符串。注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 `s` 的所有子字符串中的唯一字符）。

由于答案可能非常大，请将结果 **mod 10 ^ 9 + 7** 后再返回。

 

 **示例 1：** 

```

输入: s = "ABC"
输出: 10
解释: 所有可能的子串为："A","B","C","AB","BC" 和 "ABC"。
     其中，每一个子串都由独特字符构成。
     所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10

```
 **示例 2：** 

```

输入: s = "ABA"
输出: 8
解释: 除了 countUniqueChars("ABA") = 1 之外，其余与示例 1 相同。

```
 **示例 3：** 

```

输入：s = "LEETCODE"
输出：92

```
 

 **提示：** 
-  `0 <= s.length <= 10^4` 
-  `s` 只包含大写英文字符
 
**标签**
`字符串` `动态规划` 


## 
```python

```
>
# 829.连续整数求和
[https://leetcode-cn.com/problems/consecutive-numbers-sum](https://leetcode-cn.com/problems/consecutive-numbers-sum) 
## 原题
给定一个正整数 `n` ，返回 *连续正整数满足所有数字之和为 `n` 的组数* 。 

 

 **示** **例 1:** 

```

输入: n = 5
输出: 2
解释: 5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。
```
 **示例 2:** 

```

输入: n = 9
输出: 3
解释: 9 = 4 + 5 = 2 + 3 + 4
```
 **示例 3:** 

```

输入: n = 15
输出: 4
解释: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5
```
 

 **提示:** 
-  `1 <= n <= 10^9` ​​​​​​​
 
**标签**
`数学` `枚举` 


## 
```python

```
>
# 830.较大分组的位置
[https://leetcode-cn.com/problems/positions-of-large-groups](https://leetcode-cn.com/problems/positions-of-large-groups) 
## 原题
在一个由小写字母构成的字符串 `s` 中，包含由一些连续的相同字符所构成的分组。

例如，在字符串 `s = "abbxxxxzyy"`  中，就含有 `"a"` , `"bb"` , `"xxxx"` , `"z"` 和 `"yy"` 这样的一些分组。

分组可以用区间 `[start, end]` 表示，其中 `start` 和 `end` 分别表示该分组的起始和终止位置的下标。上例中的 `"xxxx"` 分组用区间表示为 `[3,6]` 。

我们称所有包含大于或等于三个连续字符的分组为 **较大分组** 。

找到每一个 **较大分组** 的区间， **按起始位置下标递增顺序排序后** ，返回结果。

 

 **示例 1：** 

```

输入：s = "abbxxxxzzy"
输出：[[3,6]]
解释："xxxx" 是一个起始于 3 且终止于 6 的较大分组。

```
 **示例 2：** 

```

输入：s = "abc"
输出：[]
解释："a","b" 和 "c" 均不是符合要求的较大分组。

```
 **示例 3：** 

```

输入：s = "abcdddeeeeaabbbcd"
输出：[[3,5],[6,9],[12,14]]
解释：较大分组为 "ddd", "eeee" 和 "bbb"
```
 **示例 4：** 

```

输入：s = "aba"
输出：[]

```

 

 **提示：** 
-  `1 <= s.length <= 1000` 
-  `s` 仅含小写英文字母
 
**标签**
`字符串` 


## 
```python

```
>
# 831.隐藏个人信息
[https://leetcode-cn.com/problems/masking-personal-information](https://leetcode-cn.com/problems/masking-personal-information) 
## 原题
给你一条个人信息字符串 `s` ，可能表示一个 **邮箱地址** ，也可能表示一串 **电话号码** 。返回按如下规则 **隐藏** 个人信息后的结果：

 ***电子邮件地址：*** 

一个电子邮件地址由以下部分组成：
- 一个 **名字** ，由大小写英文字母组成，后面跟着
- 一个 `'@'` 字符，后面跟着
- 一个 **域名** ，由大小写英文字母和一个位于中间的 `'.'` 字符组成。 `'.'` 不会是域名的第一个或者最后一个字符。
要想隐藏电子邮件地址中的个人信息：
-  **名字** 和 **域名** 部分的大写英文字母应当转换成小写英文字母。
-  **名字** 中间的字母（即，除第一个和最后一个字母外）必须用 5 个 `"*****"` 替换。
 ***电话号码：*** 

一个电话号码应当按下述格式组成：
- 电话号码可以由 10-13 位数字组成
- 后 10 位构成 **本地号码** 
- 前面剩下的 0-3 位，构成 **国家代码** 
- 利用 `{'+', '-', '(', ')', ' '}` 这些 **分隔字符** 按某种形式对上述数字进行分隔
要想隐藏电话号码中的个人信息：
- 移除所有 **分隔字符** 
- 隐藏个人信息后的电话号码应该遵从这种格式：
	
-  `"***-***-XXXX"` 如果国家代码为 0 位数字
-  `"+*-***-***-XXXX"` 如果国家代码为 1 位数字
-  `"+**-***-***-XXXX"` 如果国家代码为 2 位数字
-  `"+***-***-***-XXXX"` 如果国家代码为 3 位数字
	
	
-  `"XXXX"` 是最后 4 位 **本地号码** 

 
 **示例 1：** 

```

输入：s = "LeetCode@LeetCode.com"
输出："l*****e@leetcode.com"
解释：s 是一个电子邮件地址。
名字和域名都转换为小写，名字的中间用 5 个 * 替换。

```
 **示例 2：** 

```

输入：s = "AB@qq.com"
输出："a*****b@qq.com"
解释：s 是一个电子邮件地址。
名字和域名都转换为小写，名字的中间用 5 个 * 替换。
注意，尽管 "ab" 只有两个字符，但中间仍然必须有 5 个 * 。

```
 **示例 3：** 

```

输入：s = "1(234)567-890"
输出："***-***-7890"
解释：s 是一个电话号码。
共计 10 位数字，所以本地号码为 10 位数字，国家代码为 0 位数字。
因此，隐藏后的电话号码应该是 "***-***-7890" 。

```
 **示例 4：** 

```

输入：s = "86-(10)12345678"
输出："+**-***-***-5678"
解释：s 是一个电话号码。
共计 12 位数字，所以本地号码为 10 位数字，国家代码为 2 位数字。
因此，隐藏后的电话号码应该是 "+**-***-***-7890" 。

```
 

 **提示：** 
-  `s` 是一个 **有效** 的电子邮件或者电话号码
- 如果 `s` 是一个电子邮件：
	
-  `8 <= s.length <= 40` 
-  `s` 是由大小写英文字母，恰好一个 `'@'` 字符，以及 `'.'` 字符组成
	
	
- 如果 `s` 是一个电话号码：
	
-  `10 <= s.length <= 20` 
-  `s` 是由数字、空格、字符 `'('` 、 `')'` 、 `'-'` 和 `'+'` 组成
	
	
 
**标签**
`字符串` 


## 
```python

```
>
# 832.翻转图像
[https://leetcode-cn.com/problems/flipping-an-image](https://leetcode-cn.com/problems/flipping-an-image) 
## 原题
给定一个<meta charset="UTF-8" /> `n x n` 的二进制矩阵 `image` ，先 **水平** 翻转图像，然后 **反转** 图像并返回 *结果* 。

 **水平** 翻转图片就是将图片的每一行都进行翻转，即逆序。
- 例如，水平翻转 `[1,1,0]` 的结果是 `[0,1,1]` 。
 **反转** 图片的意思是图片中的 `0` 全部被 `1` 替换， `1` 全部被 `0` 替换。
- 例如，反转 `[0,1,1]` 的结果是 `[1,0,0]` 。
 

 **示例 1：** 

```

输入：image = [[1,1,0],[1,0,1],[0,0,0]]
输出：[[1,0,0],[0,1,0],[1,1,1]]
解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；
     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]

```
 **示例 2：** 

```

输入：image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
输出：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
解释：首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；
     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]

```
 

 **提示：** 

<meta charset="UTF-8" />
-  `n == image.length` 
-  `n == image[i].length` 
-  `1 <= n <= 20` 
-  `images[i][j]` == `0` 或 `1` .
 
**标签**
`数组` `双指针` `矩阵` `模拟` 


## 
```python

```
>
# 833.字符串中的查找与替换
[https://leetcode-cn.com/problems/find-and-replace-in-string](https://leetcode-cn.com/problems/find-and-replace-in-string) 
## 原题
你会得到一个字符串 `s` (索引从 0 开始)，你必须对它执行 `k` 个替换操作。替换操作以三个长度均为 `k` 的并行数组给出： `indices` , `sources` , `targets` 。

要完成第 `i` 个替换操作:
- 检查 **子字符串** `sources[i]` 是否出现在 **原字符串** `s` 的索引 `indices[i]` 处。
- 如果没有出现， **什么也不做** 。
- 如果出现，则用 `targets[i]` **替换** 该子字符串。
例如，如果 `s = "abcd"` ， `indices[i] = 0` , `sources[i] = "ab"` ， `targets[i] = "eee"` ，那么替换的结果将是 `"<u>eee</u>cd"` 。

所有替换操作必须 **同时** 发生，这意味着替换操作不应该影响彼此的索引。测试用例保证元素间 **不会重叠** 。
- 例如，一个 `s = "abc"` ， `indices = [0,1]` ， `sources = ["ab"，"bc"]` 的测试用例将不会生成，因为 `"ab"` 和 `"bc"` 替换重叠。
 *在对 `s` 执行所有替换操作后返回 **结果字符串** 。* 

 **子字符串** 是字符串中连续的字符序列。

 

 **示例 1：** 

<img src="https://assets.leetcode.com/uploads/2021/06/12/833-ex1.png" style="height: 251px; width: 411px;" />

```

输入：s = "abcd", indexes = [0,2], sources = ["a","cd"], targets = ["eee","ffff"]
输出："eeebffff"
解释：
"a" 从 s 中的索引 0 开始，所以它被替换为 "eee"。
"cd" 从 s 中的索引 2 开始，所以它被替换为 "ffff"。

```
 **示例 2：** <img src="https://assets.leetcode.com/uploads/2021/06/12/833-ex2-1.png" style="height: 251px; width: 411px;" />

```

输入：s = "abcd", indexes = [0,2], sources = ["ab","ec"], targets = ["eee","ffff"]
输出："eeecd"
解释：
"ab" 从 s 中的索引 0 开始，所以它被替换为 "eee"。
"ec" 没有从原始的 S 中的索引 2 开始，所以它没有被替换。

```
 

 **提示：** 
-  `1 <= s.length <= 1000` 
-  `k == indices.length == sources.length == targets.length` 
-  `1 <= k <= 100` 
-  `0 <= indexes[i] < s.length` 
-  `1 <= sources[i].length, targets[i].length <= 50` 
-  `s` 仅由小写英文字母组成
-  `sources[i]` 和 `targets[i]` 仅由小写英文字母组成
 
**标签**
`数组` `字符串` `排序` 


## 
```python

```
>
# 834.树中距离之和
[https://leetcode-cn.com/problems/sum-of-distances-in-tree](https://leetcode-cn.com/problems/sum-of-distances-in-tree) 
## 原题
给定一个无向、连通的树。树中有 `n` 个标记为 `0...n-1` 的节点以及 `n-1` 条边 。

给定整数 `n` 和数组 `edges` ， `edges[i] = [a<sub>i</sub>, b<sub>i</sub>]` 表示树中的节点 `a<sub>i</sub>` 和 `b<sub>i</sub>` 之间有一条边。

返回长度为 `n` 的数组 `answer` ，其中 `answer[i]` 是树中第 `i` 个节点与所有其他节点之间的距离之和。

 

 **示例 1:** 

<img src="https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist1.jpg" />

```

输入: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
输出: [8,12,6,10,10,10]
解释: 树如图所示。
我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) 
也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。

```
 **示例 2:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist2.jpg" />
```

输入: n = 1, edges = []
输出: [0]

```
 **示例 3:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist3.jpg" />
```

输入: n = 2, edges = [[1,0]]
输出: [1,1]

```
 

 **提示:** 
-  `1 <= n <= 3 * 10^4` 
-  `edges.length == n - 1` 
-  `edges[i].length == 2` 
-  `0 <= a<sub>i</sub>, b<sub>i</sub> < n` 
-  `a<sub>i</sub> != b<sub>i</sub>` 
- 给定的输入保证为有效的树
 
**标签**
`树` `深度优先搜索` `图` `动态规划` 


## 
```python

```
>
# 835.图像重叠
[https://leetcode-cn.com/problems/image-overlap](https://leetcode-cn.com/problems/image-overlap) 
## 原题
给你两个图像 `img1` 和 `img2` ，两个图像的大小都是 `n x n` ，用大小相同的二进制正方形矩阵表示。二进制矩阵仅由若干 `0` 和若干 `1` 组成。

 **转换** 其中一个图像，将所有的 `1` 向左，右，上，或下滑动任何数量的单位；然后把它放在另一个图像的上面。该转换的 **重叠** 是指两个图像 **都** 具有 `1` 的位置的数目。
请注意，转换 **不包括** 向任何方向旋转。越过矩阵边界的 `1` 都将被清除。

最大可能的重叠数量是多少？

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/09/overlap1.jpg" style="width: 450px; height: 231px;" />
```

输入：img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]
输出：3
解释：将 img1 向右移动 1 个单位，再向下移动 1 个单位。
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/09/overlap_step1.jpg" style="width: 450px; height: 105px;" />
两个图像都具有 1 的位置的数目是 3（用红色标识）。
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/09/overlap_step2.jpg" style="width: 450px; height: 231px;" />

```
 **示例 2：** 

```

输入：img1 = [[1]], img2 = [[1]]
输出：1

```
 **示例 3：** 

```

输入：img1 = [[0]], img2 = [[0]]
输出：0

```
 

 **提示：** 
-  `n == img1.length == img1[i].length` 
-  `n == img2.length == img2[i].length` 
-  `1 <= n <= 30` 
-  `img1[i][j]` 为 `0` 或 `1` 
-  `img2[i][j]` 为 `0` 或 `1` 
 
**标签**
`数组` `矩阵` 


## 
```python

```
>
# 836.矩形重叠
[https://leetcode-cn.com/problems/rectangle-overlap](https://leetcode-cn.com/problems/rectangle-overlap) 
## 原题
矩形以列表 `[x1, y1, x2, y2]` 的形式表示，其中 `(x1, y1)` 为左下角的坐标， `(x2, y2)` 是右上角的坐标。矩形的上下边平行于 x 轴，左右边平行于 y 轴。

如果相交的面积为 **正** ，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。

给出两个矩形 `rec1` 和 `rec2` 。如果它们重叠，返回 `true` ；否则，返回 `false` 。

 

 **示例 1：** 

```

输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true

```
 **示例 2：** 

```

输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
输出：false

```
 **示例 3：** 

```

输入：rec1 = [0,0,1,1], rec2 = [2,2,3,3]
输出：false

```
 

 **提示：** 
-  `rect1.length == 4` 
-  `rect2.length == 4` 
-  `-10^9 <= rec1[i], rec2[i] <= 10^9` 
-  `rec1` 和 `rec2` 表示一个面积不为零的有效矩形
 
**标签**
`几何` `数学` 


## 
```python

```
>
# 837.新 21 点
[https://leetcode-cn.com/problems/new-21-game](https://leetcode-cn.com/problems/new-21-game) 
## 原题
爱丽丝参与一个大致基于纸牌游戏 **“21点”** 规则的游戏，描述如下：

爱丽丝以 `0` 分开始，并在她的得分少于 `k` 分时抽取数字。 抽取时，她从 `[1, maxPts]` 的范围中随机获得一个整数作为分数进行累计，其中 `maxPts` 是一个整数。 每次抽取都是独立的，其结果具有相同的概率。

当爱丽丝获得 `k` 分 **或更多分** 时，她就停止抽取数字。

爱丽丝的分数不超过 `n` 的概率是多少？

与实际答案误差不超过 `10^-5` 的答案将被视为正确答案。
 

 **示例 1：** 

```

输入：n = 10, k = 1, maxPts = 10
输出：1.00000
解释：爱丽丝得到一张牌，然后停止。

```
 **示例 2：** 

```

输入：n = 6, k = 1, maxPts = 10
输出：0.60000
解释：爱丽丝得到一张牌，然后停止。 在 10 种可能性中的 6 种情况下，她的得分不超过 6 分。

```
 **示例 3：** 

```

输入：n = 21, k = 17, maxPts = 10
输出：0.73278

```
 

 **提示：** 
-  `0 <= k <= n <= 10^4` 
-  `1 <= maxPts <= 10^4` 
 
**标签**
`数学` `动态规划` `滑动窗口` `概率与统计` 


## 
```python

```
>
# 838.推多米诺
[https://leetcode-cn.com/problems/push-dominoes](https://leetcode-cn.com/problems/push-dominoes) 
## 原题
一行中有 `N` 张多米诺骨牌，我们将每张多米诺骨牌垂直竖立。

在开始时，我们同时把一些多米诺骨牌向左或向右推。

<img alt="" src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/05/19/domino.png" style="height: 160px; width: 418px;">

每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。

同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。

如果同时有多米诺骨牌落在一张垂直竖立的多米诺骨牌的两边，由于受力平衡， 该骨牌仍然保持不变。

就这个问题而言，我们会认为正在下降的多米诺骨牌不会对其它正在下降或已经下降的多米诺骨牌施加额外的力。

给定表示初始状态的字符串 "S" 。如果第 i 张多米诺骨牌被推向左边，则 `S[i] = ';L';` ；如果第 i 张多米诺骨牌被推向右边，则 `S[i] = ';R';` ；如果第 i 张多米诺骨牌没有被推动，则 `S[i] = ';.';` 。

返回表示最终状态的字符串。

 **示例** **1** **：** 

```
输入：".L.R...LR..L.."
输出："LL.RR.LLRRLL.."
```
 **示例** **2** **：** 

```
输入："RR.L"
输出："RR.L"
说明：第一张多米诺骨牌没有给第二张施加额外的力。
```
 **提示：** 
-  `0 <= N <= 10^5` 
- 表示多米诺骨牌状态的字符串只含有 `';L';` ， `';R';` ; 以及 `';.';` ;
 
**标签**
`双指针` `字符串` `动态规划` 


## 
```python

```
>
# 839.相似字符串组
[https://leetcode-cn.com/problems/similar-string-groups](https://leetcode-cn.com/problems/similar-string-groups) 
## 原题
如果交换字符串 `X` 中的两个不同位置的字母，使得它和字符串 `Y` 相等，那么称 `X` 和 `Y` 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。

例如， `"tars"` 和 `"rats"` 是相似的 (交换 `0` 与 `2` 的位置)； `"rats"` 和 `"arts"` 也是相似的，但是 `"star"` 不与 `"tars"` ， `"rats"` ，或 `"arts"` 相似。

总之，它们通过相似性形成了两个关联组： `{"tars", "rats", "arts"}` 和 `{"star"}` 。注意， `"tars"` 和 `"arts"` 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。

给你一个字符串列表 `strs` 。列表中的每个字符串都是 `strs` 中其它所有字符串的一个字母异位词。请问 `strs` 中有多少个相似字符串组？

 

 **示例 1：** 

```

输入：strs = ["tars","rats","arts","star"]
输出：2

```
 **示例 2：** 

```

输入：strs = ["omv","ovm"]
输出：1

```
 

 **提示：** 
-  `1 <= strs.length <= 300` 
-  `1 <= strs[i].length <= 300` 
-  `strs[i]` 只包含小写字母。
-  `strs` 中的所有单词都具有相同的长度，且是彼此的字母异位词。
 
**标签**
`深度优先搜索` `广度优先搜索` `并查集` `字符串` 


## 
```python

```
>
# 840.矩阵中的幻方
[https://leetcode-cn.com/problems/magic-squares-in-grid](https://leetcode-cn.com/problems/magic-squares-in-grid) 
## 原题
3 x 3 的幻方是一个填充有 **从 1 到 9** 的不同数字的 3 x 3 矩阵，其中每行，每列以及两条对角线上的各数之和都相等。

给定一个由整数组成的 `grid` ，其中有多少个 3 x 3 的 “幻方” 子矩阵？（每个子矩阵都是连续的）。

 

 **示例：** 

```
输入: [[4,3,8,4],
      [9,5,1,9],
      [2,7,6,2]]
输出: 1
解释: 
下面的子矩阵是一个 3 x 3 的幻方：
438
951
276

而这一个不是：
384
519
762

总的来说，在本示例所给定的矩阵中只有一个 3 x 3 的幻方子矩阵。

```
 **提示:** 
-  `1 <= grid.length <= 10` 
-  `1 <= grid[0].length <= 10` 
-  `0 <= grid[i][j] <= 15` 
 
**标签**
`数组` `数学` `矩阵` 


## 
```python

```
>
# 841.钥匙和房间
[https://leetcode-cn.com/problems/keys-and-rooms](https://leetcode-cn.com/problems/keys-and-rooms) 
## 原题
有 `n` 个房间，房间按从 `0` 到 `n - 1` 编号。最初，除 `0` 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。

当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。

给你一个数组 `rooms` 其中 `rooms[i]` 是你进入 `i` 号房间可以获得的钥匙集合。如果能进入 **所有** 房间返回 `true` ，否则返回 `false` 。

 
 **示例 1：** 

```

输入：rooms = [[1],[2],[3],[]]
输出：true
解释：
我们从 0 号房间开始，拿到钥匙 1。
之后我们去 1 号房间，拿到钥匙 2。
然后我们去 2 号房间，拿到钥匙 3。
最后我们去了 3 号房间。
由于我们能够进入每个房间，我们返回 true。

```
 **示例 2：** 

```

输入：rooms = [[1,3],[3,0,1],[2],[0]]
输出：false
解释：我们不能进入 2 号房间。

```
 

 **提示：** 
-  `n == rooms.length` 
-  `2 <= n <= 1000` 
-  `0 <= rooms[i].length <= 1000` 
-  `1 <= sum(rooms[i].length) <= 3000` 
-  `0 <= rooms[i][j] < n` 
- 所有 `rooms[i]` 的值 **互不相同** 
 
**标签**
`深度优先搜索` `广度优先搜索` `图` 


## 
```python

```
>
# 842.将数组拆分成斐波那契序列
[https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence](https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence) 
## 原题
给定一个数字字符串 `num` ，比如 `"123456579"` ，我们可以将它分成「斐波那契式」的序列 `[123, 456, 579]` 。

形式上， **斐波那契式** 序列是一个非负整数列表 `f` ，且满足：
-  `0 <= f[i] < 2^31` ，（也就是说，每个整数都符合 **32 位** 有符号整数类型）
-  `f.length >= 3` 
- 对于所有的 `0 <= i < f.length - 2` ，都有 `f[i] + f[i + 1] = f[i + 2]` 
另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 `0` 本身。

返回从 `num` 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 `[]` 。

 

 **示例 1：** 

```

输入：num = "1101111"
输出：[11,0,11,11]
解释：输出[110,1,111]也可以。
```
 **示例 2：** 

```

输入: num = "112358130"
输出: []
解释: 无法拆分。

```
 **示例 3：** 

```

输入："0123"
输出：[]
解释：每个块的数字不能以零开头，因此 "01"，"2"，"3" 不是有效答案。

```
 

 **提示：** 
-  `1 <= num.length <= 200` 
-  `num` 中只含有数字
 
**标签**
`字符串` `回溯` 


## 
```python

```
>
# 843.猜猜这个单词
[https://leetcode-cn.com/problems/guess-the-word](https://leetcode-cn.com/problems/guess-the-word) 
## 原题
这是一个 ** *交互式问题* ** 。

我们给出了一个由一些 **不同的** 单词组成的列表 `wordlist` ，对于每个 `wordlist[i]` 长度均为 `6` ，这个列表中的一个单词将被选作 `secret` 。

你可以调用 `Master.guess(word)` 来猜单词。你所猜的单词应当是存在于原列表并且由 `6` 个小写字母组成的类型 `string` 。

此函数将会返回一个 `integer` ，表示你的猜测与 **秘密单词** `secret` 的准确匹配（值和位置同时匹配）的数目。此外，如果你的猜测不在给定的单词列表中，它将返回 `-1` 。

对于每个测试用例，你有 `10` 次机会来猜出这个单词。当所有调用都结束时，如果您对 `Master.guess` 的调用在 `10` 次以内，并且至少有一次猜到 `secret` ，将判定为通过该用例。

 

 **示例 1:** 

```

输入: secret = "acckzz", wordlist = ["acckzz","ccbazz","eiowzz","abcczz"]
输出: You guessed the secret word correctly.
解释:
master.guess("aaaaaa") 返回 -1, 因为 "aaaaaa" 不在 wordlist 中.
master.guess("acckzz") 返回 6, 因为 "acckzz" 就是秘密，6个字母完全匹配。
master.guess("ccbazz") 返回 3, 因为 "ccbazz" 有 3 个匹配项。
master.guess("eiowzz") 返回 2, 因为 "eiowzz" 有 2 个匹配项。
master.guess("abcczz") 返回 4, 因为 "abcczz" 有 4 个匹配项。
我们调用了 5 次master.guess，其中一次猜到了秘密，所以我们通过了这个测试用例。

```
 **示例 2:** 

```

输入: secret = "hamada", wordlist = ["hamada","khaled"], numguesses = 10
输出: You guessed the secret word correctly.

```
 

 **提示:** 
-  `1 <= wordlist.length <= 100` 
-  `wordlist[i].length == 6` 
-  `wordlist[i]` 只包含小写英文字母
-  `wordlist` 中所有字符串都 **不同** 
-  `secret` 在 `wordlist` 中
-  `numguesses == 10` 
 
**标签**
`数组` `数学` `字符串` `博弈` `交互` 


## 
```python

```
>
# 844.比较含退格的字符串
[https://leetcode-cn.com/problems/backspace-string-compare](https://leetcode-cn.com/problems/backspace-string-compare) 
## 原题
给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。 `#` 代表退格字符。

 **注意：** 如果对空文本输入退格字符，文本继续为空。

 

 **示例 1：** 

```

输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。

```
 **示例 2：** 

```

输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。

```
 **示例 3：** 

```

输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。
```
 

 **提示：** 
-  `1 <= s.length, t.length <= 200` 
-  `s` 和 `t` 只含有小写字母以及字符 `'#'` 
 

 **进阶：** 
- 你可以用 `O(n)` 的时间复杂度和 `O(1)` 的空间复杂度解决该问题吗？
 
**标签**
`栈` `双指针` `字符串` `模拟` 


## 
```python

```
>
# 845.数组中的最长山脉
[https://leetcode-cn.com/problems/longest-mountain-in-array](https://leetcode-cn.com/problems/longest-mountain-in-array) 
## 原题
把符合下列属性的数组 `arr` 称为 **山脉数组** ：
-  `arr.length >= 3` 
- 存在下标 `i` （ `0 < i < arr.length - 1` ），满足
	
-  `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]` 
-  `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]` 
	
	
给出一个整数数组 `arr` ，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 `0` 。

 

 **示例 1：** 

```

输入：arr = [2,1,4,7,3,2,5]
输出：5
解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。

```
 **示例 2：** 

```

输入：arr = [2,2,2]
输出：0
解释：不存在山脉子数组。

```
 

 **提示：** 
-  `1 <= arr.length <= 10^4` 
-  `0 <= arr[i] <= 10^4` 
 

 **进阶：** 
- 你可以仅用一趟扫描解决此问题吗？
- 你可以用 `O(1)` 空间解决此问题吗？
 
**标签**
`数组` `双指针` `动态规划` `枚举` 


## 
```python

```
>
# 846.一手顺子
[https://leetcode-cn.com/problems/hand-of-straights](https://leetcode-cn.com/problems/hand-of-straights) 
## 原题
Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 `groupSize` ，并且由 `groupSize` 张连续的牌组成。

给你一个整数数组 `hand` 其中 `hand[i]` 是写在第 `i` 张牌，和一个整数 `groupSize` 。如果她可能重新排列这些牌，返回 `true` ；否则，返回 `false` 。

 
 **示例 1：** 

```

输入：hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
输出：true
解释：Alice 手中的牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。
```
 **示例 2：** 

```

输入：hand = [1,2,3,4,5], groupSize = 4
输出：false
解释：Alice 手中的牌无法被重新排列成几个大小为 4 的组。
```
 

 **提示：** 
-  `1 <= hand.length <= 10^4` 
-  `0 <= hand[i] <= 10^9` 
-  `1 <= groupSize <= hand.length` 
 

 **注意：** 此题目与 1296 重复：<a href="https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/" target="_blank">https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/</a>

 
**标签**
`贪心` `数组` `哈希表` `排序` 


## 
```python

```
>
# 847.访问所有节点的最短路径
[https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes](https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes) 
## 原题
存在一个由 `n` 个节点组成的无向连通图，图中的节点按从 `0` 到 `n - 1` 编号。

给你一个数组 `graph` 表示这个图。其中， `graph[i]` 是一个列表，由所有与节点 `i` 直接相连的节点组成。

返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。

 
 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg" style="width: 222px; height: 183px;" />
```

输入：graph = [[1,2,3],[0],[0],[0]]
输出：4
解释：一种可能的路径为 [1,0,2,0,3]
```
 **示例 2：** 

<img alt="" src="https://assets.leetcode.com/uploads/2021/05/12/shortest2-graph.jpg" style="width: 382px; height: 222px;" />

```

输入：graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]
输出：4
解释：一种可能的路径为 [0,1,4,2,3]

```
 

 **提示：** 
-  `n == graph.length` 
-  `1 <= n <= 12` 
-  `0 <= graph[i].length < n` 
-  `graph[i]` 不包含 `i` 
- 如果 `graph[a]` 包含 `b` ，那么 `graph[b]` 也包含 `a` 
- 输入的图总是连通图
 
**标签**
`位运算` `广度优先搜索` `图` `动态规划` `状态压缩` 


## 
```python

```
>
# 848.字母移位
[https://leetcode-cn.com/problems/shifting-letters](https://leetcode-cn.com/problems/shifting-letters) 
## 原题
有一个由小写字母组成的字符串 `s` ，和一个长度相同的整数数组 `shifts` 。

我们将字母表中的下一个字母称为原字母的 *移位* `shift()` （由于字母表是环绕的， `'z'` 将会变成 `'a'` ）。
- 例如， `shift('a') = 'b'<font color="#333333"><font face="Helvetica Neue, Helvetica, Arial, sans-serif"><span style="font-size:14px"><span style="background-color:#ffffff">, </span></span></font></font>` `shift('t') = 'u'` , 以及 `shift('z') = 'a'` 。
对于每个 `shifts[i] = x` ， 我们会将 `s` 中的前 `i + 1` 个字母移位 `x` 次。

返回 *将所有这些移位都应用到 `s` 后最终得到的字符串* 。

 

 **示例 1：** 

```

输入：s = "abc", shifts = [3,5,9]
输出："rpl"
解释： 
我们以 "abc" 开始。
将 S 中的第 1 个字母移位 3 次后，我们得到 "dbc"。
再将 S 中的前 2 个字母移位 5 次后，我们得到 "igc"。
最后将 S 中的这 3 个字母移位 9 次后，我们得到答案 "rpl"。

```
 **示例 2:** 

```

输入: s = "aaa", shifts = [1,2,3]
输出: "gfd"

```
 

 **提示:** 
-  `1 <= s.length <= 10^5` 
-  `s` 由小写英文字母组成
-  `shifts.length == s.length` 
-  `0 <= shifts[i] <= 10^9` 

<span style="display:block"><span style="height:0px"><span style="position:absolute">​​​​​​</span></span></span>
 
**标签**
`数组` `字符串` 


## 
```python

```
>
# 849.到最近的人的最大距离
[https://leetcode-cn.com/problems/maximize-distance-to-closest-person](https://leetcode-cn.com/problems/maximize-distance-to-closest-person) 
## 原题
给你一个数组  `seats` 表示一排座位，其中 `seats[i] = 1` 代表有人坐在第 `i` 个座位上， `seats[i] = 0` 代表座位 `i` 上是空的（ **下标从 0 开始** ）。

至少有一个空座位，且至少有一人已经坐在座位上。

亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。

返回他到离他最近的人的最大距离。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/10/distance.jpg" style="width: 650px; height: 257px;" />
```

输入：seats = [1,0,0,0,1,0,1]
输出：2
解释：
如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。
如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。
因此，他到离他最近的人的最大距离是 2 。 

```
 **示例 2：** 

```

输入：seats = [1,0,0,0]
输出：3
解释：
如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。
这是可能的最大距离，所以答案是 3 。

```
 **示例 3：** 

```

输入：seats = [0,1]
输出：1

```
 

 **提示：** 
-  `2 <= seats.length <= 2 * 10^4` 
-  `seats[i]` 为 `0` 或 `1` 
- 至少有一个 **空座位** 
- 至少有一个 **座位上有人** 
 
**标签**
`数组` 


## 
```python

```
>
# 850.矩形面积 II
[https://leetcode-cn.com/problems/rectangle-area-ii](https://leetcode-cn.com/problems/rectangle-area-ii) 
## 原题
我们给出了一个（轴对齐的）二维矩形列表 `rectangles` 。 对于 `rectangle[i] = [x1, y1, x2, y2]` ，其中（x1，y1）是矩形 `i` 左下角的坐标，<meta charset="UTF-8" /> `(x<sub>i1</sub>, y<sub>i1</sub>)` 是该矩形 **左下角** 的坐标，<meta charset="UTF-8" /> `(x<sub>i2</sub>, y<sub>i2</sub>)` 是该矩形 **右上角** 的坐标。

计算平面中所有 `rectangles` 所覆盖的 **总面积** 。任何被两个或多个矩形覆盖的区域应只计算 **一次** 。

返回 ***总面积*** 。因为答案可能太大，返回<meta charset="UTF-8" /> `10^9 + 7` 的 **模** 。

 

 **示例 1：** 

<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/06/rectangle_area_ii_pic.png" style="height: 300px; width: 400px;" />

```

输入：rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
输出：6
解释：如图所示，三个矩形覆盖了总面积为6的区域。
从(1,1)到(2,2)，绿色矩形和红色矩形重叠。
从(1,0)到(2,3)，三个矩形都重叠。

```
 **示例 2：** 

```

输入：rectangles = [[0,0,1000000000,1000000000]]
输出：49
解释：答案是 10^18 对 (10^9 + 7) 取模的结果， 即 49 。

```
 

 **提示：** 
-  `1 <= rectangles.length <= 200` 
-  `rectanges[i].length = 4` <meta charset="UTF-8" />
-  `0 <= x<sub>i1</sub>, y<sub>i1</sub>, x<sub>i2</sub>, y<sub>i2</sub> <= 10^9` 
- 矩形叠加覆盖后的总面积不会超越 `2^63 - 1` ，这意味着可以用一个 64 位有符号整数来保存面积结果。
 
**标签**
`线段树` `数组` `有序集合` `扫描线` 


## 
```python

```
>
# 851.喧闹和富有
[https://leetcode-cn.com/problems/loud-and-rich](https://leetcode-cn.com/problems/loud-and-rich) 
## 原题
有一组 `n` 个人作为实验对象，从 `0` 到 `n - 1` 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 `x` 的人简称为 "person `x` "。

给你一个数组 `richer` ，其中 `richer[i] = [a<sub>i</sub>, b<sub>i</sub>]` 表示 person `a<sub>i</sub>` 比 person `b<sub>i</sub>` 更有钱。另给你一个整数数组 `quiet` ，其中 `quiet[i]` 是 person `i` 的安静值。 `richer` 中所给出的数据 **逻辑自洽** （也就是说，在 person `x` 比 person `y` 更有钱的同时，不会出现 person `y` 比 person `x` 更有钱的情况 ）。

现在，返回一个整数数组 `answer` 作为答案，其中 `answer[x] = y` 的前提是，在所有拥有的钱肯定不少于 person `x` 的人中，person `y` 是最安静的人（也就是安静值 `quiet[y]` 最小的人）。

 

 **示例 1：** 

```

输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
输出：[5,5,2,5,4,5,6,7]
解释： 
answer[0] = 5，
person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。
唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，
但是目前还不清楚他是否比 person 0 更有钱。
answer[7] = 7，
在所有拥有的钱肯定不少于 person 7 的人中（这可能包括 person 3，4，5，6 以及 7），
最安静（有较低安静值 quiet[x]）的人是 person 7。
其他的答案也可以用类似的推理来解释。

```
 **示例 2：** 

```

输入：richer = [], quiet = [0]
输出：[0]

```

 

 **提示：** 
-  `n == quiet.length` 
-  `1 <= n <= 500` 
-  `0 <= quiet[i] < n` 
-  `quiet` 的所有值 **互不相同** 
-  `0 <= richer.length <= n * (n - 1) / 2` 
-  `0 <= a<sub>i</sub>, b<sub>i</sub> < n` 
-  `a<sub>i </sub>!= b<sub>i</sub>` 
-  `richer` 中的所有数对 **互不相同** 
- 对 **** `richer` 的观察在逻辑上是一致的
 
**标签**
`深度优先搜索` `图` `拓扑排序` `数组` 


## 
```python

```
>
# 852.山脉数组的峰顶索引
[https://leetcode-cn.com/problems/peak-index-in-a-mountain-array](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array) 
## 原题
符合下列属性的数组 `arr` 称为 **山脉数组** ：

-  `arr.length >= 3` 
- 存在 `i` （ `0 < i < arr.length - 1` ）使得：
	
-  `arr[0] < arr[1] < ... arr[i-1] < arr[i]` 
-  `arr[i] > arr[i+1] > ... > arr[arr.length - 1]` 
	
	
给你由整数组成的山脉数组 `arr` ，返回任何满足 `arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1]` 的下标 `i` 。

 

 **示例 1：** 

```

输入：arr = [0,1,0]
输出：1

```
 **示例 2：** 

```

输入：arr = [0,2,1,0]
输出：1

```
 **示例 3：** 

```

输入：arr = [0,10,5,2]
输出：1

```
 **示例 4：** 

```

输入：arr = [3,4,5,1]
输出：2

```
 **示例 5：** 

```

输入：arr = [24,69,100,99,79,78,67,36,26,19]
输出：2

```
 

 **提示：** 
-  `3 <= arr.length <= 10^4` 
-  `0 <= arr[i] <= 10^6` 
- 题目数据保证 `arr` 是一个山脉数组
 

 **进阶：** 很容易想到时间复杂度 `O(n)` 的解决方案，你可以设计一个 `O(log(n))` 的解决方案吗？

 
**标签**
`数组` `二分查找` 


## 
```python

```
>
# 853.车队
[https://leetcode-cn.com/problems/car-fleet](https://leetcode-cn.com/problems/car-fleet) 
## 原题
在一条单行道上，有 `n` 辆车开往同一目的地。目的地是几英里以外的 `target` 。

给定两个整数数组 `position` 和 `speed` ，长度都是 `n` ，其中 `position[i]` 是第 `i` 辆车的位置， `speed[i]` 是第 `i` 辆车的速度(单位是英里/小时)。

一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车 **以相同的速度** 紧接着行驶。此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于相同的位置。

 **车队** 是一些由行驶在相同位置、具有相同速度的车组成的非空集合。注意，一辆车也可以是一个车队。

即便一辆车在目的地才赶上了一个车队，它们仍然会被视作是同一个车队。

返回到达目的地的 **车队数量** 。

 

 **示例 1：** 

```

输入：target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
输出：3
解释：
从 10 和 8 开始的车会组成一个车队，它们在 12 处相遇。
从 0 处开始的车无法追上其它车，所以它自己就是一个车队。
从 5 和 3 开始的车会组成一个车队，它们在 6 处相遇。
请注意，在到达目的地之前没有其它车会遇到这些车队，所以答案是 3。

```
 **示例 2:** 

```

输入: target = 10, position = [3], speed = [3]
输出: 1
解释: 只有一辆车，因此只有一个车队。

```
 **示例 3:** 

```

输入: target = 100, position = [0,2,4], speed = [4,2,1]
输出: 1
解释:
以0(速度4)和2(速度2)出发的车辆组成车队，在4点相遇。舰队以2的速度前进。
然后，车队(速度2)和以4(速度1)出发的汽车组成一个车队，在6点相遇。舰队以1的速度前进，直到到达目标。
```
 

 **提示：** 
-  `n == position.length == speed.length` 
-  `1 <= n <= 10^5` 
-  `0 < target <= 10^6` 
-  `0 <= position[i] < target` 
-  `position` 中每个值都 **不同** 
-  `0 < speed[i] <= 10^6` 
 
**标签**
`栈` `数组` `排序` `单调栈` 


## 
```python

```
>
# 854.相似度为 K 的字符串
[https://leetcode-cn.com/problems/k-similar-strings](https://leetcode-cn.com/problems/k-similar-strings) 
## 原题
如果可以通过将 `A` 中的两个小写字母精确地交换位置 `K` 次得到与 `B` 相等的字符串，我们称字符串 `A` 和 `B` 的相似度为 `K` （ `K` 为非负整数）。

给定两个字母异位词 `A` 和 `B` ，返回 `A` 和 `B` 的相似度 `K` 的最小值。

 

 **示例 1：** 

```
输入：A = "ab", B = "ba"
输出：1

```
 **示例 2：** 

```
输入：A = "abc", B = "bca"
输出：2

```
 **示例 3：** 

```
输入：A = "abac", B = "baca"
输出：2

```
 **示例 4：** 

```
输入：A = "aabc", B = "abca"
输出：2
```
 

 **提示：** 
-  `1 <= A.length == B.length <= 20` 
-  `A` 和 `B` 只包含集合 `{';a';, ';b';, ';c';, ';d';, ';e';, ';f';}` 中的小写字母。
 
**标签**
`广度优先搜索` `字符串` 


## 
```python

```
>
# 855.考场就座
[https://leetcode-cn.com/problems/exam-room](https://leetcode-cn.com/problems/exam-room) 
## 原题
在考场里，一排有 `N` 个座位，分别编号为 `0, 1, 2, ..., N-1` 。

当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)

返回 `ExamRoom(int N)` 类，它有两个公开的函数：其中，函数 `ExamRoom.seat()` 会返回一个 `int` （整型数据），代表学生坐的位置；函数 `ExamRoom.leave(int p)` 代表坐在座位 `p` 上的学生现在离开了考场。每次调用 `ExamRoom.leave(p)` 时都保证有学生坐在座位 `p` 上。

 

 **示例：** 

```
输入：["ExamRoom","seat","seat","seat","seat","leave","seat"], [[10],[],[],[],[],[4],[]]
输出：[null,0,9,4,2,null,5]
解释：
ExamRoom(10) -> null
seat() -> 0，没有人在考场里，那么学生坐在 0 号座位上。
seat() -> 9，学生最后坐在 9 号座位上。
seat() -> 4，学生最后坐在 4 号座位上。
seat() -> 2，学生最后坐在 2 号座位上。
leave(4) -> null
seat() -> 5，学生最后坐在 5 号座位上。

```
 

 **提示：** 
-  `1 <= N <= 10^9` 
- 在所有的测试样例中 `ExamRoom.seat()` 和 `ExamRoom.leave()` 最多被调用 `10^4` 次。
- 保证在调用 `ExamRoom.leave(p)` 时有学生正坐在座位 `p` 上。
 
**标签**
`设计` `有序集合` 


## 
```python

```
>
# 856.括号的分数
[https://leetcode-cn.com/problems/score-of-parentheses](https://leetcode-cn.com/problems/score-of-parentheses) 
## 原题
给定一个平衡括号字符串 `S` ，按下述规则计算该字符串的分数：
-  `()` 得 1 分。
-  `AB` 得 `A + B` 分，其中 A 和 B 是平衡括号字符串。
-  `(A)` 得 `2 * A` 分，其中 A 是平衡括号字符串。
 

 **示例 1：** 

```
输入： "()"
输出： 1

```
 **示例 2：** 

```
输入： "(())"
输出： 2

```
 **示例 3：** 

```
输入： "()()"
输出： 2

```
 **示例 4：** 

```
输入： "(()(()))"
输出： 6

```
 

 **提示：** 
-  `S` 是平衡括号字符串，且只含有 `(` 和 `)` 。
-  `2 <= S.length <= 50` 
 
**标签**
`栈` `字符串` 


## 
```python

```
>
# 857.雇佣 K 名工人的最低成本
[https://leetcode-cn.com/problems/minimum-cost-to-hire-k-workers](https://leetcode-cn.com/problems/minimum-cost-to-hire-k-workers) 
## 原题
有 `n` 名工人。 给定两个数组 `quality` 和 `wage` ，其中， `quality[i]` 表示第 `i` 名工人的工作质量，其最低期望工资为 `wage[i]` 。

现在我们想雇佣 `k` 名工人组成一个 *工资组。* 在雇佣 一组 `k` 名工人时，我们必须按照下述规则向他们支付工资：
- 对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。
- 工资组中的每名工人至少应当得到他们的最低期望工资。
给定整数 `k` ，返回 *组成满足上述条件的付费群体所需的最小金额* 。在实际答案的 `10^-5` 以内的答案将被接受。。

 
 **示例 1：** 

```

输入： quality = [10,20,5], wage = [70,50,30], k = 2
输出： 105.00000
解释： 我们向 0 号工人支付 70，向 2 号工人支付 35。
```
 **示例 2：** 

```

输入： quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3
输出： 30.66667
解释： 我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。
```
 

 **提示：** 
-  `n == quality.length == wage.length` 
-  `1 <= k <= n <= 10^4` 
-  `1 <= quality[i], wage[i] <= 10^4` 
 
**标签**
`贪心` `数组` `排序` `堆（优先队列）` 


## 
```python

```
>
# 858.镜面反射
[https://leetcode-cn.com/problems/mirror-reflection](https://leetcode-cn.com/problems/mirror-reflection) 
## 原题
有一个特殊的正方形房间，每面墙上都有一面镜子。除西南角以外，每个角落都放有一个接受器，编号为  `0` ，  `1` ，以及  `2` 。

正方形房间的墙壁长度为  `p` ，一束激光从西南角射出，首先会与东墙相遇，入射点到接收器 `0` 的距离为 `q` 。

返回光线最先遇到的接收器的编号（保证光线最终会遇到一个接收器）。

 

 **示例：** 

```

输入： p = 2, q = 1
输出： 2
解释： 这条光线在第一次被反射回左边的墙时就遇到了接收器 2 。
<img alt="" src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/06/22/reflection.png" style="height: 217px; width: 218px;" />
```
 

 **提示：** 
-  `1 <= p <= 1000` 
-  `0 <= q <= p` 
 
**标签**
`几何` `数学` 


## 
```python

```
>
# 859.亲密字符串
[https://leetcode-cn.com/problems/buddy-strings](https://leetcode-cn.com/problems/buddy-strings) 
## 原题
给你两个字符串 `s` 和 `goal` ，只要我们可以通过交换 `s` 中的两个字母得到与 `goal` 相等的结果，就返回 `true` ；否则返回 `false` 。

交换字母的定义是：取两个下标 `i` 和 `j` （下标从 `0` 开始）且满足 `i != j` ，接着交换 `s[i]` 和 `s[j]` 处的字符。
- 例如，在 `"abcd"` 中交换下标 `0` 和下标 `2` 的元素可以生成 `"cbad"` 。
 

 **示例 1：** 

```

输入：s = "ab", goal = "ba"
输出：true
解释：你可以交换 s[0] = 'a' 和 s[1] = 'b' 生成 "ba"，此时 s 和 goal 相等。
```
 **示例 2：** 

```

输入：s = "ab", goal = "ab"
输出：false
解释：你只能交换 s[0] = 'a' 和 s[1] = 'b' 生成 "ba"，此时 s 和 goal 不相等。
```
 **示例 3：** 

```

输入：s = "aa", goal = "aa"
输出：true
解释：你可以交换 s[0] = 'a' 和 s[1] = 'a' 生成 "aa"，此时 s 和 goal 相等。

```
 **示例 4：** 

```

输入：s = "aaaaaaabc", goal = "aaaaaaacb"
输出：true

```
 

 **提示：** 
-  `1 <= s.length, goal.length <= 2 * 10^4` 
-  `s` 和 `goal` 由小写英文字母组成
 
**标签**
`哈希表` `字符串` 


## 
```python

```
>
# 860.柠檬水找零
[https://leetcode-cn.com/problems/lemonade-change](https://leetcode-cn.com/problems/lemonade-change) 
## 原题
在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 `5` 美元、 `10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。

 

 **示例 1：** 

```

输入：bills = [5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。

```
 **示例 2：** 

```

输入：bills = [5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。

```
 **示例 3：** 

```

输入：bills = [5,5,10]
输出：true

```
 **示例 4：** 

```

输入：bills = [10,10]
输出：false
```
 

 **提示：** 
-  `1 <= bills.length <= 10^5` 
-  `bills[i]` 不是 `5` 就是 `10` 或是 `20` 
 
**标签**
`贪心` `数组` 


## 
```python

```
>
# 861.翻转矩阵后的得分
[https://leetcode-cn.com/problems/score-after-flipping-matrix](https://leetcode-cn.com/problems/score-after-flipping-matrix) 
## 原题
有一个二维矩阵 `A` 其中每个元素的值为 `0` 或 `1` 。

移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 `0` 都更改为 `1` ，将所有 `1` 都更改为 `0` 。

在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。

返回尽可能高的分数。

 
 **示例：** 

```
输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
输出：39
解释：
转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
```
 

 **提示：** 
-  `1 <= A.length <= 20` 
-  `1 <= A[0].length <= 20` 
-  `A[i][j]` 是 `0` 或 `1` 
 
**标签**
`贪心` `位运算` `数组` `矩阵` 


## 
```python

```
>
# 862.和至少为 K 的最短子数组
[https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k](https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k) 
## 原题
给你一个整数数组 `nums` 和一个整数 `k` ，找出 `nums` 中和至少为 `k` 的 **最短非空子数组** ，并返回该子数组的长度。如果不存在这样的 **子数组** ，返回 `-1` 。

 **子数组** 是数组中 **连续** 的一部分。

 
 **示例 1：** 

```

输入：nums = [1], k = 1
输出：1

```
 **示例 2：** 

```

输入：nums = [1,2], k = 4
输出：-1

```
 **示例 3：** 

```

输入：nums = [2,-1,2], k = 3
输出：3

```
 

 **提示：** 
-  `1 <= nums.length <= 10^5` 
-  `-10^5 <= nums[i] <= 10^5` 
-  `1 <= k <= 10^9` 
 
**标签**
`队列` `数组` `二分查找` `前缀和` `滑动窗口` `单调队列` `堆（优先队列）` 


## 
```python

```
>
# 863.二叉树中所有距离为 K 的结点
[https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree) 
## 原题
给定一个二叉树（具有根结点 `root` ）， 一个目标结点 `target` ，和一个整数值 `k` 。

返回到目标结点 `target` 距离为 `k` 的所有结点的值的列表。 答案可以以 **任何顺序** 返回。

 
 **示例 1：** 

<img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" style="height: 429px; width: 500px;" />

```

输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2
输出：[7,4,1]
解释：所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1

```
 **示例 2:** 

```

输入: root = [1], target = 1, k = 3
输出: []

```
 

 **提示:** 
- 节点数在 `[1, 500]` 范围内
-  `0 <= Node.val <= 500` 
-  `Node.val` 中所有值 **不同** 
- 目标结点 `target` 是树上的结点。
-  `0 <= k <= 1000` 
 

 
**标签**
`树` `深度优先搜索` `广度优先搜索` `二叉树` 


## 
```python

```
>
# 864.获取所有钥匙的最短路径
[https://leetcode-cn.com/problems/shortest-path-to-get-all-keys](https://leetcode-cn.com/problems/shortest-path-to-get-all-keys) 
## 原题
给定一个二维网格 `grid` ，其中：
- <font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.6px"><span style="background-color:#f9f2f4">'.'</span></span></font></font> 代表一个空房间
- <font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.6px"><span style="background-color:#f9f2f4">'#'</span></span></font></font> 代表一堵
- <font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.6px"><span style="background-color:#f9f2f4">'@'</span></span></font></font> 是起点
- 小写字母代表钥匙
- 大写字母代表锁
我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。

假设 k 为 钥匙/锁 的个数，且满足 `1 <= k <= 6` ，字母表中的前 `k` 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。

返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 `-1` 。

 

 **示例 1：** 

<img src="https://assets.leetcode.com/uploads/2021/07/23/lc-keys2.jpg" />

```

输入：grid = ["@.a.#","###.#","b.A.B"]
输出：8
解释：目标是获得所有钥匙，而不是打开所有锁。

```
 **示例 2：** 

<img src="https://assets.leetcode.com/uploads/2021/07/23/lc-key2.jpg" />

```

输入：grid = ["@..aA","..B#.","....b"]
输出：6

```
 **示例 3:** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-keys3.jpg" />
```

输入: grid = ["@Aa"]
输出: -1
```
 

 **提示：** 
-  `m == grid.length` 
-  `n == grid[i].length` 
-  `1 <= m, n <= 30` 
-  `grid[i][j]` 只含有 `'.'` , `'#'` , `'@'` , `'a'-` `'f` `'` 以及 `'A'-'F'` 
- 钥匙的数目范围是 `[1, 6]` 
- 每个钥匙都对应一个 **不同** 的字母
- 每个钥匙正好打开一个对应的锁
 
**标签**
`位运算` `广度优先搜索` 


## 
```python

```
>
# 865.具有所有最深节点的最小子树
[https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes](https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes) 
## 原题
给定一个根为 `root` 的二叉树，每个节点的深度是 **该节点到根的最短距离** 。

返回包含原始树中所有 **最深节点** 的 *最小子树* 。

如果一个节点在 **整个树** 的任意节点之间具有最大的深度，则该节点是 **最深的** 。

一个节点的 **子树** 是该节点加上它的所有后代的集合。

 

 **示例 1：** 

<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png" style="width: 300px;" />

```

输入：root = [3,5,1,6,2,0,8,null,null,7,4]
输出：[2,7,4]
解释：
我们返回值为 2 的节点，在图中用黄色标记。
在图中用蓝色标记的是树的最深的节点。
注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。

```
 **示例 2：** 

```

输入：root = [1]
输出：[1]
解释：根节点是树中最深的节点。
```
 **示例 3：** 

```

输入：root = [0,1,3,null,2]
输出：[2]
解释：树中最深的节点为 2 ，有效子树为节点 2、1 和 0 的子树，但节点 2 的子树最小。
```
 

 **提示：** 
- 树中节点的数量在<meta charset="UTF-8" /> `[1, 500]` 范围内。
-  `0 <= Node.val <= 500` 
- 每个节点的值都是 **独一无二** 的。
 

 **注意：** 本题与力扣 1123 重复：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/" target="_blank">https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves</a>

 
**标签**
`树` `深度优先搜索` `广度优先搜索` `哈希表` `二叉树` 


## 
```python

```
>
# 866.回文素数
[https://leetcode-cn.com/problems/prime-palindrome](https://leetcode-cn.com/problems/prime-palindrome) 
## 原题
求出大于或等于 `N` 的最小回文素数。

回顾一下，如果一个数大于 1，且其因数只有 1 和它自身，那么这个数是 *素数* 。

例如，2，3，5，7，11 以及 13 是素数。

回顾一下，如果一个数从左往右读与从右往左读是一样的，那么这个数是 *回文数。* 

例如，12321 是回文数。

 

 **示例 1：** 

```
输入：6
输出：7

```
 **示例 2：** 

```
输入：8
输出：11

```
 **示例 3：** 

```
输入：13
输出：101
```
 

 **提示：** 
-  `1 <= N <= 10^8` 
- 答案肯定存在，且小于 `2 * 10^8` 。
 

 

 
**标签**
`数学` 


## 
```python

```
>
# 867.转置矩阵
[https://leetcode-cn.com/problems/transpose-matrix](https://leetcode-cn.com/problems/transpose-matrix) 
## 原题
给你一个二维整数数组 `matrix` ， 返回 `matrix` 的 **转置矩阵** 。

矩阵的 **转置** 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。

<img alt="" src="https://assets.leetcode.com/uploads/2021/02/10/hint_transpose.png" style="width: 600px; height: 197px;" />

 

 **示例 1：** 

```

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[1,4,7],[2,5,8],[3,6,9]]

```
 **示例 2：** 

```

输入：matrix = [[1,2,3],[4,5,6]]
输出：[[1,4],[2,5],[3,6]]

```
 

 **提示：** 
-  `m == matrix.length` 
-  `n == matrix[i].length` 
-  `1 <= m, n <= 1000` 
-  `1 <= m * n <= 10^5` 
-  `-10^9 <= matrix[i][j] <= 10^9` 
 
**标签**
`数组` `矩阵` `模拟` 


## 
```python

```
>
# 868.二进制间距
[https://leetcode-cn.com/problems/binary-gap](https://leetcode-cn.com/problems/binary-gap) 
## 原题
给定一个正整数 `n` ，找到并返回 `n` 的二进制表示中两个 **相邻** 1 之间的 **最长距离** 。如果不存在两个相邻的 1，返回 `0` 。

如果只有 `0` 将两个 `1` 分隔开（可能不存在 `0` ），则认为这两个 1 彼此 **相邻** 。两个 `1` 之间的距离是它们的二进制表示中位置的绝对差。例如， `"1001"` 中的两个 `1` 的距离为 3 。

 
 **示例 1：** 

```

输入：n = 22
输出：2
解释：22 的二进制是 "10110" 。
在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。
第一对相邻的 1 中，两个 1 之间的距离为 2 。
第二对相邻的 1 中，两个 1 之间的距离为 1 。
答案取两个距离之中最大的，也就是 2 。

```
 **示例 2：** 

```

输入：n = 8
输出：0
解释：8 的二进制是 "1000" 。
在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。

```
 **示例 3：** 

```

输入：n = 5
输出：2
解释：5 的二进制是 "101" 。

```
 

 **提示：** 
-  `1 <= n <= 10^9` 
 
**标签**
`位运算` `数学` 


## 
```python

```
>
# 869.重新排序得到 2 的幂
[https://leetcode-cn.com/problems/reordered-power-of-2](https://leetcode-cn.com/problems/reordered-power-of-2) 
## 原题
给定正整数 `n` ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。

如果我们可以通过上述方式得到 2 的幂，返回 `true` ；否则，返回 `false` 。

 
 **示例 1：** 

```

输入：n = 1
输出：true

```
 **示例 2：** 

```

输入：n = 10
输出：false

```
 

 **提示：** 
-  `1 <= n <= 10^9` 
 
**标签**
`数学` `计数` `枚举` `排序` 


## 
```python

```
>
# 870.优势洗牌
[https://leetcode-cn.com/problems/advantage-shuffle](https://leetcode-cn.com/problems/advantage-shuffle) 
## 原题
给定两个大小相等的数组 `A` 和 `B` ，A 相对于 B 的 *优势* 可以用满足 `A[i] > B[i]` 的索引 `i` 的数目来描述。

返回 `A` 的 **任意** 排列，使其相对于 `B` 的优势最大化。

 

 **示例 1：** 

```
输入：A = [2,7,11,15], B = [1,10,4,11]
输出：[2,11,7,15]

```
 **示例 2：** 

```
输入：A = [12,24,8,32], B = [13,25,32,11]
输出：[24,32,8,12]

```
 

 **提示：** 
-  `1 <= A.length = B.length <= 10000` 
-  `0 <= A[i] <= 10^9` 
-  `0 <= B[i] <= 10^9` 
 
**标签**
`贪心` `数组` `排序` 


## 
```python

```
>
# 871.最低加油次数
[https://leetcode-cn.com/problems/minimum-number-of-refueling-stops](https://leetcode-cn.com/problems/minimum-number-of-refueling-stops) 
## 原题
汽车从起点出发驶向目的地，该目的地位于出发位置东面 `target` 英里处。

沿途有加油站，每个 `station[i]` 代表一个加油站，它位于出发位置东面 `station[i][0]` 英里处，并且有 `station[i][1]` 升汽油。

假设汽车油箱的容量是无限的，其中最初有 `startFuel` 升燃料。它每行驶 1 英里就会用掉 1 升汽油。

当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。

为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 `-1` 。

注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。

 

 **示例 1：** 

```
输入：target = 1, startFuel = 1, stations = []
输出：0
解释：我们可以在不加油的情况下到达目的地。

```
 **示例 2：** 

```
输入：target = 100, startFuel = 1, stations = [[10,100]]
输出：-1
解释：我们无法抵达目的地，甚至无法到达第一个加油站。

```
 **示例 3：** 

```
输入：target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]
输出：2
解释：
我们出发时有 10 升燃料。
我们开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。
然后，我们从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），
并将汽油从 10 升加到 50 升。然后我们开车抵达目的地。
我们沿途在1两个加油站停靠，所以返回 2 。

```
 

 **提示：** 
-  `1 <= target, startFuel, stations[i][1] <= 10^9` 
-  `0 <= stations.length <= 500` 
-  `0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target` 
 
**标签**
`贪心` `数组` `动态规划` `堆（优先队列）` 


## 
```python

```
>
# 872.叶子相似的树
[https://leetcode-cn.com/problems/leaf-similar-trees](https://leetcode-cn.com/problems/leaf-similar-trees) 
## 原题
请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 **叶值序列** 。

<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png" style="height: 336px; width: 400px;" />

举个例子，如上图所示，给定一棵叶值序列为 `(6, 7, 4, 9, 8)` 的树。

如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 *叶相似* 的。

如果给定的两个根结点分别为 `root1` 和 `root2` 的树是叶相似的，则返回 `true` ；否则返回 `false` 。

 

 **示例 1：** 

<img alt="" src="https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg" style="height: 237px; width: 600px;" />

```

输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
输出：true

```
 **示例 2：** 

<img alt="" src="https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg" style="height: 110px; width: 300px;" />

```

输入：root1 = [1,2,3], root2 = [1,3,2]
输出：false

```
 

 **提示：** 
- 给定的两棵树结点数在 `[1, 200]` 范围内
- 给定的两棵树上的值在 `[0, 200]` 范围内
 
**标签**
`树` `深度优先搜索` `二叉树` 


## 
```python

```
>
# 873.最长的斐波那契子序列的长度
[https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence](https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence) 
## 原题
如果序列  `X_1, X_2, ..., X_n`  满足下列条件，就说它是  *斐波那契式 * 的：
-  `n >= 3` 
- 对于所有  `i + 2 <= n` ，都有  `X_i + X_{i+1} = X_{i+2}` 
给定一个 **严格递增** 的正整数数组形成序列 arr ，找到 <font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.600000381469727px"><span style="caret-color:#c7254e"><span style="background-color:#f9f2f4">arr</span></span></span></font></font> 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。

 *（回想一下，子序列是从原序列 <font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.600000381469727px"><span style="caret-color:#c7254e"><span style="background-color:#f9f2f4">arr</span></span></span></font></font> 中派生出来的，它从 <font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.600000381469727px"><span style="caret-color:#c7254e"><span style="background-color:#f9f2f4">arr</span></span></span></font></font> 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如，  `[3, 5, 8]`  是  `[3, 4, 5, 6, 7, 8]`  的一个子序列）* 

 
 **示例 1：** 

```

输入: arr = [1,2,3,4,5,6,7,8]
输出: 5
解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。

```
 **示例 2：** 

```

输入: arr = [1,3,7,11,12,14,18]
输出: 3
解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。

```
 

 **提示：** 
-  `3 <= arr.length <= 1000` 
- 
	 `1 <= arr[i] < arr[i + 1] <= 10^9` 
	
 
**标签**
`数组` `哈希表` `动态规划` 


## 
```python

```
>
# 874.模拟行走机器人
[https://leetcode-cn.com/problems/walking-robot-simulation](https://leetcode-cn.com/problems/walking-robot-simulation) 
## 原题
机器人在一个无限大小的 XY 网格平面上行走，从点  `(0, 0)` 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 `commands` ：
-  `-2` ：向左转  `90` 度
-  `-1` ：向右转 `90` 度
-  `1 <= x <= 9` ：向前移动  `x`  个单位长度
在网格上有一些格子被视为障碍物  `obstacles` 。第 `i`  个障碍物位于网格点   `obstacles[i] = (x<sub>i</sub>, y<sub>i</sub>)` 。

机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。

返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 `5` ，则返回 `25` ）
 
<p class="MachineTrans-lang-zh-CN"> **注意：** 
	<li class="MachineTrans-lang-zh-CN">北表示 `+Y` 方向。
	<li class="MachineTrans-lang-zh-CN">东表示 `+X` 方向。
	<li class="MachineTrans-lang-zh-CN">南表示 `-Y` 方向。
	<li class="MachineTrans-lang-zh-CN">西表示 `-X` 方向。
 

 **示例 1：** 

```

输入：commands = [4,-1,3], obstacles = []
输出：25
解释：
机器人开始位于 (0, 0)：
1. 向北移动 4 个单位，到达 (0, 4)
2. 右转
3. 向东移动 3 个单位，到达 (3, 4)
距离原点最远的是 (3, 4) ，距离为 3^2 + 4^2 = 25
```
 **示例 2：** 

```

输入：commands = [4,-1,4,-2,4], obstacles = [[2,4]]
输出：65
解释：机器人开始位于 (0, 0)：
1. 向北移动 4 个单位，到达 (0, 4)
2. 右转
3. 向东移动 1 个单位，然后被位于 (2, 4) 的障碍物阻挡，机器人停在 (1, 4)
4. 左转
5. 向北走 4 个单位，到达 (1, 8)
距离原点最远的是 (1, 8) ，距离为 1^2 + 8^2 = 65
```
 

 **提示：** 
-  `1 <= commands.length <= 10^4` 
-  `commands[i]` is one of the values in the list `[-2,-1,1,2,3,4,5,6,7,8,9]` .
-  `0 <= obstacles.length <= 10^4` 
-  `-3 * 10^4 <= x<sub>i</sub>, y<sub>i</sub> <= 3 * 10^4` 
- 答案保证小于 `2^31` 
 
**标签**
`数组` `模拟` 


## 
```python

```
>
# 875.爱吃香蕉的珂珂
[https://leetcode-cn.com/problems/koko-eating-bananas](https://leetcode-cn.com/problems/koko-eating-bananas) 
## 原题
珂珂喜欢吃香蕉。这里有 `N` 堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉。警卫已经离开了，将在 `H` 小时后回来。

珂珂可以决定她吃香蕉的速度 `K` （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 `K` 根。如果这堆香蕉少于 `K` 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  

珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。

返回她可以在 `H` 小时内吃掉所有香蕉的最小速度 `K` （ `K` 为整数）。

 
 **示例 1：** 

```
输入: piles = [3,6,7,11], H = 8
输出: 4

```
 **示例 2：** 

```
输入: piles = [30,11,23,4,20], H = 5
输出: 30

```
 **示例 3：** 

```
输入: piles = [30,11,23,4,20], H = 6
输出: 23

```
 

 **提示：** 
-  `1 <= piles.length <= 10^4` 
-  `piles.length <= H <= 10^9` 
-  `1 <= piles[i] <= 10^9` 
 
**标签**
`数组` `二分查找` 


## 
```python

```
>
# 876.链表的中间结点
[https://leetcode-cn.com/problems/middle-of-the-linked-list](https://leetcode-cn.com/problems/middle-of-the-linked-list) 
## 原题
给定一个头结点为 `head`  的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

 

 **示例 1：** 

```

输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.

```
 **示例 2：** 

```

输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。

```
 

 **提示：** 
- 给定链表的结点数介于  `1`  和  `100`  之间。
 
**标签**
`链表` `双指针` 


## 
```python

```
>
# 877.石子游戏
[https://leetcode-cn.com/problems/stone-game](https://leetcode-cn.com/problems/stone-game) 
## 原题
Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子， **排成一行** ；每堆都有 **正** 整数颗石子，数目为 `piles[i]` 。

游戏以谁手中的石子最多来决出胜负。石子的 **总数** 是 **奇数** ，所以没有平局。

Alice 和 Bob 轮流进行， **Alice 先开始** 。 每回合，玩家从行的 **开始** 或 **结束** 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 **石子最多** 的玩家 **获胜** 。

假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 `true` ，当 Bob 赢得比赛时返回 `false` 。

 

 **示例 1：** 

```

输入：piles = [5,3,4,5]
输出：true
解释：
Alice 先开始，只能拿前 5 颗或后 5 颗石子 。
假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。
如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。
这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。

```
 **示例 2：** 

```

输入：piles = [3,7,2,3]
输出：true

```
 

 **提示：** 
-  `2 <= piles.length <= 500` 
-  `piles.length` 是 **偶数** 
-  `1 <= piles[i] <= 500` 
-  `sum(piles[i])` 是 **奇数** 
 
**标签**
`数组` `数学` `动态规划` `博弈` 


## 
```python

```
>
# 878.第 N 个神奇数字
[https://leetcode-cn.com/problems/nth-magical-number](https://leetcode-cn.com/problems/nth-magical-number) 
## 原题
如果正整数可以被 A 或 B 整除，那么它是神奇的。

返回第 N 个神奇数字。由于答案可能非常大， **返回它模** `10^9 + 7` **的结果** 。

 
 **示例 1：** 

```
输入：N = 1, A = 2, B = 3
输出：2

```
 **示例 2：** 

```
输入：N = 4, A = 2, B = 3
输出：6

```
 **示例 3：** 

```
输入：N = 5, A = 2, B = 4
输出：10

```
 **示例 4：** 

```
输入：N = 3, A = 6, B = 4
输出：8

```
 

 **提示：** 
-  `1 <= N <= 10^9` 
-  `2 <= A <= 40000` 
-  `2 <= B <= 40000` 
 
**标签**
`数学` `二分查找` 


## 
```python

```
>
# 879.盈利计划
[https://leetcode-cn.com/problems/profitable-schemes](https://leetcode-cn.com/problems/profitable-schemes) 
## 原题
集团里有 `n` 名员工，他们可以完成各种各样的工作创造利润。

第  `i`  种工作会产生  `profit[i]`  的利润，它要求  `group[i]`  名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。

工作的任何至少产生  `minProfit` 利润的子集称为 **盈利计划** 。并且工作的成员总数最多为 `n` 。

有多少种计划可以选择？因为答案很大，所以 **返回结果模 ** `10^9 + 7` ** 的值** 。
 

 **示例 1：** 

```

输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]
输出：2
解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。
总的来说，有两种计划。
```
 **示例 2：** 

```

输入：n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]
输出：7
解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。
有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。
```
 

 **提示：** 
-  `1 <= n <= 100` 
-  `0 <= minProfit <= 100` 
-  `1 <= group.length <= 100` 
-  `1 <= group[i] <= 100` 
-  `profit.length == group.length` 
-  `0 <= profit[i] <= 100` 
 
**标签**
`数组` `动态规划` 


## 
```python

```
>
# 880.索引处的解码字符串
[https://leetcode-cn.com/problems/decoded-string-at-index](https://leetcode-cn.com/problems/decoded-string-at-index) 
## 原题
给定一个编码字符串 `S` 。请你找出 **解码字符串** 并将其写入磁带。解码时，从编码字符串中 **每次读取一个字符** ，并采取以下步骤：
- 如果所读的字符是字母，则将该字母写在磁带上。
- 如果所读的字符是数字（例如 `d` ），则整个当前磁带总共会被重复写 `d-1` 次。
现在，对于给定的编码字符串 `S` 和索引 `K` ，查找并返回解码字符串中的第 `K` 个字母。

 

 **示例 1：** 

```
输入：S = "leet2code3", K = 10
输出："o"
解释：
解码后的字符串为 "leetleetcodeleetleetcodeleetleetcode"。
字符串中的第 10 个字母是 "o"。

```
 **示例 2：** 

```
输入：S = "ha22", K = 5
输出："h"
解释：
解码后的字符串为 "hahahaha"。第 5 个字母是 "h"。

```
 **示例 3：** 

```
输入：S = "a2345678999999999999999", K = 1
输出："a"
解释：
解码后的字符串为 "a" 重复 8301530446056247680 次。第 1 个字母是 "a"。

```
 

 **提示：** 
-  `2 <= S.length <= 100` 
-  `S` 只包含小写字母与数字 `2` 到 `9` 。
-  `S` 以字母开头。
-  `1 <= K <= 10^9` 
- 题目保证 `K` 小于或等于解码字符串的长度。
- 解码后的字符串保证少于 `2^63` 个字母。
 
**标签**
`栈` `字符串` 


## 
```python

```
>
# 881.救生艇
[https://leetcode-cn.com/problems/boats-to-save-people](https://leetcode-cn.com/problems/boats-to-save-people) 
## 原题
给定数组<meta charset="UTF-8" /> `people` 。 `people[i]` 表示第 `i` ^ 个人的体重 ， **船的数量不限** ，每艘船可以承载的最大重量为 `limit` 。

每艘船最多可同时载两人，但条件是这些人的重量之和最多为 `limit` 。

返回 *承载所有人所需的最小船数* 。

 

 **示例 1：** 

```

输入：people = [1,2], limit = 3
输出：1
解释：1 艘船载 (1, 2)

```
 **示例 2：** 

```

输入：people = [3,2,2,1], limit = 3
输出：3
解释：3 艘船分别载 (1, 2), (2) 和 (3)

```
 **示例 3：** 

```

输入：people = [3,5,3,4], limit = 5
输出：4
解释：4 艘船分别载 (3), (3), (4), (5)
```
 

 **提示：** 
-  `1 <= people.length <= 5 * 10^4` 
-  `1 <= people[i] <= limit <= 3 * 10^4` 
 
**标签**
`贪心` `数组` `双指针` `排序` 


## 
```python

```
>
# 882.细分图中的可到达结点
[https://leetcode-cn.com/problems/reachable-nodes-in-subdivided-graph](https://leetcode-cn.com/problems/reachable-nodes-in-subdivided-graph) 
## 原题
给你一个无向图（ **原始图** ），图中有 `n` 个节点，编号从 `0` 到 `n - 1` 。你决定将图中的每条边 **细分** 为一条节点链，每条边之间的新节点数各不相同。

图用由边组成的二维数组 `edges` 表示，其中 `edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cnt<sub>i</sub>]` 表示原始图中节点 `u<sub>i</sub>` 和 `v<sub>i</sub>` 之间存在一条边， `cnt<sub>i</sub>` 是将边 **细分** 后的新节点总数。注意， `cnt<sub>i</sub> == 0` 表示边不可细分。

要 **细分** 边 `[ui, vi]` ，需要将其替换为 `(cnt<sub>i</sub> + 1)` 条新边，和 `cnt<sub>i</sub>` 个新节点。新节点为 `x<sub>1</sub>` , `x<sub>2</sub>` , ..., `x<sub>cnt<sub>i</sub></sub>` ，新边为 `[u<sub>i</sub>, x<sub>1</sub>]` , `[x<sub>1</sub>, x<sub>2</sub>]` , `[x<sub>2</sub>, x<sub>3</sub>]` , ..., `[x<sub>cnt<sub>i</sub>+1</sub>, x<sub>cnt<sub>i</sub></sub>]` , `[x<sub>cnt<sub>i</sub></sub>, v<sub>i</sub>]` 。

现在得到一个 **新的细分图** ，请你计算从节点 `0` 出发，可以到达多少个节点？如果节点间距离是 `maxMoves` 或更少，则视为 **可以到达** 。

给你原始图和 `maxMoves` ，返回 *新的细分图中从节点 `0` 出发* ** *可到达的节点数* ** 。

 

 **示例 1：** 
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png" style="height: 247px; width: 600px;" />
```

输入：edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3
输出：13
解释：边的细分情况如上图所示。
可以到达的节点已经用黄色标注出来。

```
 **示例 2：** 

```

输入：edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4
输出：23

```
 **示例 3：** 

```

输入：edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5
输出：1
解释：节点 0 与图的其余部分没有连通，所以只有节点 0 可以到达。

```
 

 **提示：** 
-  `0 <= edges.length <= min(n * (n - 1) / 2, 10^4)` 
-  `edges[i].length == 3` 
-  `0 <= u<sub>i</sub> < v<sub>i</sub> < n` 
- 图中 **不存在平行边** 
-  `0 <= cnt<sub>i</sub> <= 10^4` 
-  `0 <= maxMoves <= 10^9` 
-  `1 <= n <= 3000` 
 
**标签**
`图` `最短路` `堆（优先队列）` 


## 
```python

```
>
# 883.三维形体投影面积
[https://leetcode-cn.com/problems/projection-area-of-3d-shapes](https://leetcode-cn.com/problems/projection-area-of-3d-shapes) 
## 原题
在<meta charset="UTF-8" /> `n x n` 的网格<meta charset="UTF-8" /> `grid` 中，我们放置了一些与 x，y，z 三轴对齐的<meta charset="UTF-8" /> `1 x 1 x 1` 立方体。

每个值 `v = grid[i][j]` 表示 `v` 个正方体叠放在单元格 `(i, j)` 上。

现在，我们查看这些立方体在 `xy` 、 `yz` 和 `zx` 平面上的 *投影* 。

 **投影** 就像影子，将 **三维** 形体映射到一个 **二维** 平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。

返回 *所有三个投影的总面积* 。

 
 **示例 1：** 

<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/02/shadow.png" style="height: 214px; width: 800px;" />

```

输入：[[1,2],[3,4]]
输出：17
解释：这里有该形体在三个轴对齐平面上的三个投影(“阴影部分”)。

```
 **示例 2:** 

```

输入：grid = [[2]]
输出：5

```
 **示例 3：** 

```

输入：[[1,0],[0,2]]
输出：8

```
 

 **提示：** 
-  `n == grid.length == grid[i].length` 
-  `1 <= n <= 50` 
-  `0 <= grid[i][j] <= 50` 
 
**标签**
`几何` `数组` `数学` `矩阵` 


## 
```python

```
>
# 884.两句话中的不常见单词
[https://leetcode-cn.com/problems/uncommon-words-from-two-sentences](https://leetcode-cn.com/problems/uncommon-words-from-two-sentences) 
## 原题
 **句子** 是一串由空格分隔的单词。每个 **单词** 仅由小写字母组成。

如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 **没有出现** ，那么这个单词就是 **不常见的** 。

给你两个 **句子** `s1` 和 `s2` ，返回所有 **不常用单词** 的列表。返回列表中单词可以按 **任意顺序** 组织。

 
 **示例 1：** 

```

输入：s1 = "this apple is sweet", s2 = "this apple is sour"
输出：["sweet","sour"]

```
 **示例 2：** 

```

输入：s1 = "apple apple", s2 = "banana"
输出：["banana"]

```
 

 **提示：** 
-  `1 <= s1.length, s2.length <= 200` 
-  `s1` 和 `s2` 由小写英文字母和空格组成
-  `s1` 和 `s2` 都不含前导或尾随空格
-  `s1` 和 `s2` 中的所有单词间均由单个空格分隔
 
**标签**
`哈希表` `字符串` 


## 
```python

```
>
# 885.螺旋矩阵 III
[https://leetcode-cn.com/problems/spiral-matrix-iii](https://leetcode-cn.com/problems/spiral-matrix-iii) 
## 原题
在 `R` 行 `C` 列的矩阵上，我们从 `(r0, c0)` 面朝东面开始

这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。

现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。

每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。

最终，我们到过网格的所有 `R * C` 个空间。

按照访问顺序返回表示网格位置的坐标列表。

 

 **示例 1：** 

```
输入：R = 1, C = 4, r0 = 0, c0 = 0
输出：[[0,0],[0,1],[0,2],[0,3]]

<img alt="" src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/08/24/example_1.png" style="height: 99px; width: 174px;">

```
 

 **示例 2：** 

```
输入：R = 5, C = 6, r0 = 1, c0 = 4
输出：[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]

<img alt="" src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/08/24/example_2.png" style="height: 142px; width: 202px;">

```
 

 **提示：** 
-  `1 <= R <= 100` 
-  `1 <= C <= 100` 
-  `0 <= r0 < R` 
-  `0 <= c0 < C` 
 
**标签**
`数组` `矩阵` `模拟` 


## 
```python

```
>
# 886.可能的二分法
[https://leetcode-cn.com/problems/possible-bipartition](https://leetcode-cn.com/problems/possible-bipartition) 
## 原题
给定一组 `n` 人（编号为 `1, 2, ..., n` ）， 我们想把每个人分进 **任意** 大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。

给定整数 `n` 和数组 `dislikes` ，其中 `dislikes[i] = [a<sub>i</sub>, b<sub>i</sub>]` ，表示不允许将编号为 `a<sub>i</sub>` 和 `b<sub>i</sub>` 的人归入同一组。当可以用这种方法将所有人分进两组时，返回 `true` ；否则返回 `false` 。

 
 **示例 1：** 

```

输入：n = 4, dislikes = [[1,2],[1,3],[2,4]]
输出：true
解释：group1 [1,4], group2 [2,3]

```
 **示例 2：** 

```

输入：n = 3, dislikes = [[1,2],[1,3],[2,3]]
输出：false

```
 **示例 3：** 

```

输入：n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]
输出：false

```
 

 **提示：** 
-  `1 <= n <= 2000` 
-  `0 <= dislikes.length <= 10^4` 
-  `dislikes[i].length == 2` 
-  `1 <= dislikes[i][j] <= n` 
-  `a<sub>i</sub> < b<sub>i</sub>` 
-  `dislikes` 中每一组都 **不同** 
 

 
**标签**
`深度优先搜索` `广度优先搜索` `并查集` `图` 


## 
```python

```
>
# 887.鸡蛋掉落
[https://leetcode-cn.com/problems/super-egg-drop](https://leetcode-cn.com/problems/super-egg-drop) 
## 原题
给你 `k` 枚相同的鸡蛋，并可以使用一栋从第 `1` 层到第 `n` 层共有 `n` 层楼的建筑。

已知存在楼层 `f` ，满足  `0 <= f <= n` ，任何从 **高于** `f` 的楼层落下的鸡蛋都会碎，从 `f` 楼层或比它低的楼层落下的鸡蛋都不会破。

每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 `x` 扔下（满足  `1 <= x <= n` ）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 **重复使用** 这枚鸡蛋。

请你计算并返回要确定 `f` **确切的值** 的 **最小操作次数** 是多少？
 

 **示例 1：** 

```

输入：k = 1, n = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 
如果它没碎，那么肯定能得出 f = 2 。 
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 

```
 **示例 2：** 

```

输入：k = 2, n = 6
输出：3

```
 **示例 3：** 

```

输入：k = 3, n = 14
输出：4

```
 

 **提示：** 
-  `1 <= k <= 100` 
-  `1 <= n <= 10^4` 
 
**标签**
`数学` `二分查找` `动态规划` 


## 
```python

```
>
# 888.公平的糖果交换
[https://leetcode-cn.com/problems/fair-candy-swap](https://leetcode-cn.com/problems/fair-candy-swap) 
## 原题
爱丽丝和鲍勃拥有不同总数量的糖果。给你两个数组 `aliceSizes` 和 `bobSizes` ， `aliceSizes[i]` 是爱丽丝拥有的第 `i` 盒糖果中的糖果数量， `bobSizes[j]` 是鲍勃拥有的第 `j` 盒糖果中的糖果数量。

两人想要互相交换一盒糖果，这样在交换之后，他们就可以拥有相同总数量的糖果。一个人拥有的糖果总数量是他们每盒糖果数量的总和。

返回一个整数数组 `answer` ，其中 `answer[0]` 是爱丽丝必须交换的糖果盒中的糖果的数目， `answer[1]` 是鲍勃必须交换的糖果盒中的糖果的数目。如果存在多个答案，你可以返回其中 **任何一个** 。题目测试用例保证存在与输入对应的答案。

 

 **示例 1：** 

```

输入：aliceSizes = [1,1], bobSizes = [2,2]
输出：[1,2]

```
 **示例 2：** 

```

输入：aliceSizes = [1,2], bobSizes = [2,3]
输出：[1,2]

```
 **示例 3：** 

```

输入：aliceSizes = [2], bobSizes = [1,3]
输出：[2,3]

```
 **示例 4：** 

```

输入：aliceSizes = [1,2,5], bobSizes = [2,4]
输出：[5,4]

```
 

 **提示：** 
-  `1 <= aliceSizes.length, bobSizes.length <= 10^4` 
-  `1 <= aliceSizes[i], bobSizes[j] <= 10^5` 
- 爱丽丝和鲍勃的糖果总数量不同。
- 题目数据保证对于给定的输入至少存在一个有效答案。
 
**标签**
`数组` `哈希表` `二分查找` `排序` 


## 
```python

```
>
# 889.根据前序和后序遍历构造二叉树
[https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal) 
## 原题
给定两个整数数组， `preorder` 和 `postorder` ，其中 `preorder` 是一个具有 **无重复** 值的二叉树的前序遍历， `postorder` 是同一棵树的后序遍历，重构并返回二叉树。

如果存在多个答案，您可以返回其中 **任何** 一个。

 

 **示例 1：** 

<img src="https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg" style="height: 265px; width: 304px;" />

```

输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
输出：[1,2,3,4,5,6,7]

```
 **示例 2:** 

```

输入: preorder = [1], postorder = [1]
输出: [1]

```
 

 **提示：** 
-  `1 <= preorder.length <= 30` 
-  `1 <= preorder[i] <= preorder.length` 
-  `preorder` 中所有值都 **不同** 
-  `postorder.length == preorder.length` 
-  `1 <= postorder[i] <= postorder.length` 
-  `postorder` 中所有值都 **不同** 
- 保证 `preorder` 和 `postorder` 是同一棵二叉树的前序遍历和后序遍历
 
**标签**
`树` `数组` `哈希表` `分治` `二叉树` 


## 
```python

```
>
# 890.查找和替换模式
[https://leetcode-cn.com/problems/find-and-replace-pattern](https://leetcode-cn.com/problems/find-and-replace-pattern) 
## 原题
你有一个单词列表 `words` 和一个模式 `pattern` ，你想知道 `words` 中的哪些单词与模式匹配。

如果存在字母的排列 `p` ，使得将模式中的每个字母 `x` 替换为 `p(x)` 之后，我们就得到了所需的单词，那么单词与模式是匹配的。

 *（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）* 

返回 `words` 中与给定模式匹配的单词列表。

你可以按任何顺序返回答案。

 

 **示例：** 

```
输入：words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb"
输出：["mee","aqq"]
解释：
"mee" 与模式匹配，因为存在排列 {a -> m, b -> e, ...}。
"ccc" 与模式不匹配，因为 {a -> c, b -> c, ...} 不是排列。
因为 a 和 b 映射到同一个字母。
```
 

 **提示：** 
-  `1 <= words.length <= 50` 
-  `1 <= pattern.length = words[i].length <= 20` 
 
**标签**
`数组` `哈希表` `字符串` 


## 
```python

```
>
# 891.子序列宽度之和
[https://leetcode-cn.com/problems/sum-of-subsequence-widths](https://leetcode-cn.com/problems/sum-of-subsequence-widths) 
## 原题
一个序列的 **宽度** 定义为该序列中最大元素和最小元素的差值。

给你一个整数数组 `nums` ，返回 `nums` 的所有非空 **子序列** 的 **宽度之和** 。由于答案可能非常大，请返回对 `10^9 + 7` **取余** 后的结果。

 **子序列** 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如， `[3,6,2,7]` 就是数组 `[0,3,1,6,2,2,7]` 的一个子序列。

 

 **示例 1：** 

```

输入：nums = [2,1,3]
输出：6
解释：子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。
相应的宽度是 0, 0, 0, 1, 1, 2, 2 。
宽度之和是 6 。

```
 **示例 2：** 

```

输入：nums = [2]
输出：0

```
 

 **提示：** 
-  `1 <= nums.length <= 10^5` 
-  `1 <= nums[i] <= 10^5` 
 
**标签**
`数组` `数学` `排序` 


## 
```python

```
>
# 892.三维形体的表面积
[https://leetcode-cn.com/problems/surface-area-of-3d-shapes](https://leetcode-cn.com/problems/surface-area-of-3d-shapes) 
## 原题
给你一个 `n * n` 的网格 `grid` ，上面放置着一些 `1 x 1 x 1` 的正方体。每个值 `v = grid[i][j]` 表示 `v` 个正方体叠放在对应单元格 `(i, j)` 上。

放置好正方体后，任何直接相邻的正方体都会互相粘在一起，形成一些不规则的三维形体。

请你返回最终这些形体的总表面积。

 **注意：** 每个形体的底面也需要计入表面积中。

 
 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/08/tmp-grid2.jpg" style="height: 80px; width: 80px;" />
```

输入：grid = [[1,2],[3,4]]
输出：34

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/08/tmp-grid4.jpg" style="height: 100px; width: 100px;" />
```

输入：grid = [[1,1,1],[1,0,1],[1,1,1]]
输出：32

```
 **示例 3：** 
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/08/tmp-grid5.jpg" style="height: 100px; width: 100px;" />
```

输入：grid = [[2,2,2],[2,1,2],[2,2,2]]
输出：46

```
 

 **提示：** 
-  `n == grid.length` 
-  `n == grid[i].length` 
-  `1 <= n <= 50` 
-  `0 <= grid[i][j] <= 50` 
 
**标签**
`几何` `数组` `数学` `矩阵` 


## 
```python

```
>
# 893.特殊等价字符串组
[https://leetcode-cn.com/problems/groups-of-special-equivalent-strings](https://leetcode-cn.com/problems/groups-of-special-equivalent-strings) 
## 原题
给你一个字符串数组 `words` 。

一步操作中，你可以交换字符串 `words[i]` 的任意两个偶数下标对应的字符或任意两个奇数下标对应的字符。

对两个字符串 `words[i]` 和 `words[j]` 而言，如果经过任意次数的操作， `words[i] == words[j]` ，那么这两个字符串是 **特殊等价** 的。
- 例如， `words[i] = "zzxy"` 和 `words[j] = "xyzz"` 是一对 **特殊等价** 字符串，因为可以按 `"zzxy" -> "xzzy" -> "xyzz"` 的操作路径使 `words[i] == words[j]` 。
现在规定， ** `words` ** 的 **一组特殊等价字符串** 就是 `words` 的一个同时满足下述条件的非空子集：
- 该组中的每一对字符串都是 **特殊等价** 的
- 该组字符串已经涵盖了该类别中的所有特殊等价字符串，容量达到理论上的最大值（也就是说，如果一个字符串不在该组中，那么这个字符串就 **不会** 与该组内任何字符串特殊等价）
返回 `words` 中 **特殊等价字符串组** 的数量。

 
 **示例 1：** 

```

输入：words = ["abcd","cdab","cbad","xyzz","zzxy","zzyx"]
输出：3
解释：
其中一组为 ["abcd", "cdab", "cbad"]，因为它们是成对的特殊等价字符串，且没有其他字符串与这些字符串特殊等价。
另外两组分别是 ["xyzz", "zzxy"] 和 ["zzyx"]。特别需要注意的是，"zzxy" 不与 "zzyx" 特殊等价。

```
 **示例 2：** 

```

输入：words = ["abc","acb","bac","bca","cab","cba"]
输出：3
解释：3 组 ["abc","cba"]，["acb","bca"]，["bac","cab"]

```
 

 **提示：** 
-  `1 <= words.length <= 1000` 
-  `1 <= words[i].length <= 20` 
- 所有 `words[i]` 都只由小写字母组成。
- 所有 `words[i]` 都具有相同的长度。
 
**标签**
`数组` `哈希表` `字符串` 


## 
```python

```
>
# 894.所有可能的满二叉树
[https://leetcode-cn.com/problems/all-possible-full-binary-trees](https://leetcode-cn.com/problems/all-possible-full-binary-trees) 
## 原题
 *满二叉树* 是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。

返回包含 `N` 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。

答案中每个树的每个 `结点` 都 **必须** 有 `node.val=0` 。

你可以按任何顺序返回树的最终列表。

 

 **示例：** 

```
输入：7
输出：[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]
解释：
<img alt="" src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/08/24/fivetrees.png" style="height: 400px; width: 700px;">

```
 

 **提示：** 
-  `1 <= N <= 20` 
 
**标签**
`树` `递归` `记忆化搜索` `动态规划` `二叉树` 


## 
```python

```
>
# 895.最大频率栈
[https://leetcode-cn.com/problems/maximum-frequency-stack](https://leetcode-cn.com/problems/maximum-frequency-stack) 
## 原题
设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出 **出现频率** 最高的元素。

实现 `FreqStack` 类:
- <meta charset="UTF-8" /> `FreqStack()` 构造一个空的堆栈。
- <meta charset="UTF-8" /> `void push(int val)` 将一个整数 `val` 压入栈顶。
- <meta charset="UTF-8" /> `int pop()` 删除并返回堆栈中出现频率最高的元素。
	
- 如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。
	
	
 

 **示例 1：** 

```

输入：
["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],
[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
输出：[null,null,null,null,null,null,null,5,7,5,4]
解释：
FreqStack = new FreqStack();
freqStack.push (5);//堆栈为 [5]
freqStack.push (7);//堆栈是 [5,7]
freqStack.push (5);//堆栈是 [5,7,5]
freqStack.push (7);//堆栈是 [5,7,5,7]
freqStack.push (4);//堆栈是 [5,7,5,7,4]
freqStack.push (5);//堆栈是 [5,7,5,7,4,5]
freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。
freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。
freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。
freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。
```
 

 **提示：** 
-  `0 <= val <= 10^9` 
-  `push` 和 `pop` 的操作数不大于 `2 * 10^4` 。
- 输入保证在调用 `pop` 之前堆栈中至少有一个元素。
 
**标签**
`栈` `设计` `哈希表` `有序集合` 


## 
```python

```
>
# 896.单调数列
[https://leetcode-cn.com/problems/monotonic-array](https://leetcode-cn.com/problems/monotonic-array) 
## 原题
如果数组是单调递增或单调递减的，那么它是 **单调** *的* 。

如果对于所有 `i <= j` ， `nums[i] <= nums[j]` ，那么数组 `nums` 是单调递增的。 如果对于所有 `i <= j` ， `nums[i]> = nums[j]` ，那么数组 `nums` 是单调递减的。

当给定的数组 `nums` 是单调数组时返回 `true` ，否则返回 `false` 。

 
 **示例 1：** 

```

输入：nums = [1,2,2,3]
输出：true

```
 **示例 2：** 

```

输入：nums = [6,5,4,4]
输出：true

```
 **示例 3：** 

```

输入：nums = [1,3,2]
输出：false

```
 

 **提示：** 
-  `1 <= nums.length <= 10^5` 
-  `-10^5 <= nums[i] <= 10^5` 
 
**标签**
`数组` 


## 
```python

```
>
# 897.递增顺序搜索树
[https://leetcode-cn.com/problems/increasing-order-search-tree](https://leetcode-cn.com/problems/increasing-order-search-tree) 
## 原题
给你一棵二叉搜索树的<meta charset="UTF-8" /> `root` ，请你 **按中序遍历** 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。

 

 **示例 1：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg" style="height: 350px; width: 600px;" />
```

输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]

```
 **示例 2：** 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg" style="height: 114px; width: 300px;" />
```

输入：root = [5,1,7]
输出：[1,null,5,null,7]

```
 

 **提示：** 
- 树中节点数的取值范围是 `[1, 100]` 
-  `0 <= Node.val <= 1000` 
 
**标签**
`栈` `树` `深度优先搜索` `二叉搜索树` `二叉树` 


## 
```python

```
>
# 898.子数组按位或操作
[https://leetcode-cn.com/problems/bitwise-ors-of-subarrays](https://leetcode-cn.com/problems/bitwise-ors-of-subarrays) 
## 原题
我们有一个非负整数数组<meta charset="UTF-8" /> `arr` 。

对于每个（连续的）子数组<meta charset="UTF-8" /> `sub = [arr[i], arr[i + 1], ..., arr[j]]` （ `i <= j` ），我们对<meta charset="UTF-8" /> `sub` 中的每个元素进行按位或操作，获得结果<meta charset="UTF-8" /> `arr[i] | arr[i + 1] | ... | arr[j]` 。

返回可能结果的数量。 多次出现的结果在最终答案中仅计算一次。

 

 **示例 1：** 

```

输入：arr = [0]
输出：1
解释：
只有一个可能的结果 0 。

```
 **示例 2：** 

```

输入：arr = [1,1,2]
输出：3
解释：
可能的子数组为 [1]，[1]，[2]，[1, 1]，[1, 2]，[1, 1, 2]。
产生的结果为 1，1，2，1，3，3 。
有三个唯一值，所以答案是 3 。

```
 **示例 3：** 

```

输入：arr = [1,2,4]
输出：6
解释：
可能的结果是 1，2，3，4，6，以及 7 。

```
 

 **提示：** <meta charset="UTF-8" />
-  `1 <= nums.length <= 5 * 10^4` 
-  `0 <= nums[i] <= 10^9` ​​​​​​​
 
**标签**
`位运算` `数组` `动态规划` 


## 
```python

```
>
# 899.有序队列
[https://leetcode-cn.com/problems/orderly-queue](https://leetcode-cn.com/problems/orderly-queue) 
## 原题
给定一个字符串 `s` 和一个整数 `k` 。你可以从 `s` 的前 `k` 个字母中选择一个，并把它加到字符串的末尾。

返回 *在应用上述步骤的任意数量的移动后，字典上最小的字符串* 。

 

 **示例 1：** 

```

输入：s = "cba", k = 1
输出："acb"
解释：
在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。
在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。

```
 **示例 2：** 

```

输入：s = "baaca", k = 3
输出："aaabc"
解释：
在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。
在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。

```
 

 **提示：** 
-  `1 <= k <= S.length <= 1000` 
-  `s` 只由小写字母组成。
 
**标签**
`数学` `字符串` `排序` 


## 
```python

```
>
# 900.RLE 迭代器
[https://leetcode-cn.com/problems/rle-iterator](https://leetcode-cn.com/problems/rle-iterator) 
## 原题
我们可以使用游程编码(即 **RLE** )来编码一个整数序列。在偶数长度 `encoding` ( **从 0 开始** )的游程编码数组中，对于所有偶数 `i` ， `encoding[i]` 告诉我们非负整数 `encoding[i + 1]` 在序列中重复的次数。
- 例如，序列 `arr = [8,8,8,5,5]` 可以被编码为 `encoding =[3,8,2,5]` 。 `encoding =[3,8,0,9,2,5]` 和 `encoding =[2,8,1,8,2,5]` 也是 `arr` 有效的 **RLE** 。
给定一个游程长度的编码数组，设计一个迭代器来遍历它。

实现 `RLEIterator` 类:
-  `RLEIterator(int[] encoded)` 用编码后的数组初始化对象。
-  `int next(int n)` 以这种方式耗尽后 `n` 个元素并返回最后一个耗尽的元素。如果没有剩余的元素要耗尽，则返回 `-1` 。
 

 **示例 1：** 

```

输入：
["RLEIterator","next","next","next","next"]
[[[3,8,0,9,2,5]],[2],[1],[1],[2]]
输出：
[null,8,8,5,-1]
解释：
RLEIterator rLEIterator = new RLEIterator([3, 8, 0, 9, 2, 5]); // 这映射到序列 [8,8,8,5,5]。
rLEIterator.next(2); // 耗去序列的 2 个项，返回 8。现在剩下的序列是 [8, 5, 5]。
rLEIterator.next(1); // 耗去序列的 1 个项，返回 8。现在剩下的序列是 [5, 5]。
rLEIterator.next(1); // 耗去序列的 1 个项，返回 5。现在剩下的序列是 [5]。
rLEIterator.next(2); // 耗去序列的 2 个项，返回 -1。 这是由于第一个被耗去的项是 5，
但第二个项并不存在。由于最后一个要耗去的项不存在，我们返回 -1。

```
 

 **提示：** 
-  `2 <= encoding.length <= 1000` 
-  `encoding.length` 为偶
-  `0 <= encoding[i] <= 10^9` 
-  `1 <= n <= 10^9` 
- 每个测试用例调用 `next` 不高于 `1000` 次 
 
**标签**
`设计` `数组` `计数` `迭代器` 


## 
```python

```
>
